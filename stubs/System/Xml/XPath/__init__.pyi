import typing, abc
from System.Collections import IComparer, IEqualityComparer, IEnumerable, IEnumerator
from System.Xml import IXmlNamespaceResolver, XmlNamespaceManager, XmlNameTable, XmlNodeOrder, XmlWriter, XmlNamespaceScope, XmlReader
from System import DateTime, ICloneable
from System.Xml.Schema import XmlSchemaType, IXmlSchemaInfo, XmlSchemaSet, ValidationEventHandler
from System.Collections.Generic import IDictionary_2

class IXPathNavigable(typing.Protocol):
    @abc.abstractmethod
    def CreateNavigator(self) -> XPathNavigator: ...


class XmlCaseOrder(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    None_ : XmlCaseOrder # 0
    UpperFirst : XmlCaseOrder # 1
    LowerFirst : XmlCaseOrder # 2


class XmlDataType(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Text : XmlDataType # 1
    Number : XmlDataType # 2


class XmlSortOrder(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Ascending : XmlSortOrder # 1
    Descending : XmlSortOrder # 2


class XPathExpression(abc.ABC):
    @property
    def Expression(self) -> str: ...
    @property
    def ReturnType(self) -> XPathResultType: ...
    @abc.abstractmethod
    def Clone(self) -> XPathExpression: ...
    # Skipped AddSort due to it being static, abstract and generic.

    AddSort : AddSort_MethodGroup
    class AddSort_MethodGroup:
        @typing.overload
        def __call__(self, expr: typing.Any, comparer: IComparer) -> None:...
        @typing.overload
        def __call__(self, expr: typing.Any, order: XmlSortOrder, caseOrder: XmlCaseOrder, lang: str, dataType: XmlDataType) -> None:...

    # Skipped Compile due to it being static, abstract and generic.

    Compile : Compile_MethodGroup
    class Compile_MethodGroup:
        @typing.overload
        def __call__(self, xpath: str) -> XPathExpression:...
        @typing.overload
        def __call__(self, xpath: str, nsResolver: IXmlNamespaceResolver) -> XPathExpression:...

    # Skipped SetContext due to it being static, abstract and generic.

    SetContext : SetContext_MethodGroup
    class SetContext_MethodGroup:
        @typing.overload
        def __call__(self, nsManager: XmlNamespaceManager) -> None:...
        @typing.overload
        def __call__(self, nsResolver: IXmlNamespaceResolver) -> None:...



class XPathItem(abc.ABC):
    @property
    def IsNode(self) -> bool: ...
    @property
    def TypedValue(self) -> typing.Any: ...
    @property
    def Value(self) -> str: ...
    @property
    def ValueAsBoolean(self) -> bool: ...
    @property
    def ValueAsDateTime(self) -> DateTime: ...
    @property
    def ValueAsDouble(self) -> float: ...
    @property
    def ValueAsInt(self) -> int: ...
    @property
    def ValueAsLong(self) -> int: ...
    @property
    def ValueType(self) -> typing.Type[typing.Any]: ...
    @property
    def XmlType(self) -> XmlSchemaType: ...
    # Skipped ValueAs due to it being static, abstract and generic.

    ValueAs : ValueAs_MethodGroup
    class ValueAs_MethodGroup:
        @typing.overload
        def __call__(self, returnType: typing.Type[typing.Any]) -> typing.Any:...
        @typing.overload
        def __call__(self, returnType: typing.Type[typing.Any], nsResolver: IXmlNamespaceResolver) -> typing.Any:...



class XPathNamespaceScope(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    All : XPathNamespaceScope # 0
    ExcludeXml : XPathNamespaceScope # 1
    Local : XPathNamespaceScope # 2


class XPathNavigator(XPathItem, IXmlNamespaceResolver, IXPathNavigable, ICloneable):
    @property
    def BaseURI(self) -> str: ...
    @property
    def CanEdit(self) -> bool: ...
    @property
    def HasAttributes(self) -> bool: ...
    @property
    def HasChildren(self) -> bool: ...
    @property
    def InnerXml(self) -> str: ...
    @InnerXml.setter
    def InnerXml(self, value: str) -> str: ...
    @property
    def IsEmptyElement(self) -> bool: ...
    @property
    def IsNode(self) -> bool: ...
    @property
    def LocalName(self) -> str: ...
    @property
    def Name(self) -> str: ...
    @property
    def NamespaceURI(self) -> str: ...
    @property
    def NameTable(self) -> XmlNameTable: ...
    @classmethod
    @property
    def NavigatorComparer(cls) -> IEqualityComparer: ...
    @property
    def NodeType(self) -> XPathNodeType: ...
    @property
    def OuterXml(self) -> str: ...
    @OuterXml.setter
    def OuterXml(self, value: str) -> str: ...
    @property
    def Prefix(self) -> str: ...
    @property
    def SchemaInfo(self) -> IXmlSchemaInfo: ...
    @property
    def TypedValue(self) -> typing.Any: ...
    @property
    def UnderlyingObject(self) -> typing.Any: ...
    @property
    def Value(self) -> str: ...
    @property
    def ValueAsBoolean(self) -> bool: ...
    @property
    def ValueAsDateTime(self) -> DateTime: ...
    @property
    def ValueAsDouble(self) -> float: ...
    @property
    def ValueAsInt(self) -> int: ...
    @property
    def ValueAsLong(self) -> int: ...
    @property
    def ValueType(self) -> typing.Type[typing.Any]: ...
    @property
    def XmlLang(self) -> str: ...
    @property
    def XmlType(self) -> XmlSchemaType: ...
    def AppendChildElement(self, prefix: str, localName: str, namespaceURI: str, value: str) -> None: ...
    def CheckValidity(self, schemas: XmlSchemaSet, validationEventHandler: ValidationEventHandler) -> bool: ...
    @abc.abstractmethod
    def Clone(self) -> XPathNavigator: ...
    def ComparePosition(self, nav: XPathNavigator) -> XmlNodeOrder: ...
    def Compile(self, xpath: str) -> XPathExpression: ...
    def CreateAttribute(self, prefix: str, localName: str, namespaceURI: str, value: str) -> None: ...
    def CreateAttributes(self) -> XmlWriter: ...
    def CreateNavigator(self) -> XPathNavigator: ...
    def DeleteRange(self, lastSiblingToDelete: XPathNavigator) -> None: ...
    def DeleteSelf(self) -> None: ...
    def GetAttribute(self, localName: str, namespaceURI: str) -> str: ...
    def GetNamespace(self, name: str) -> str: ...
    def GetNamespacesInScope(self, scope: XmlNamespaceScope) -> IDictionary_2[str, str]: ...
    def InsertElementAfter(self, prefix: str, localName: str, namespaceURI: str, value: str) -> None: ...
    def InsertElementBefore(self, prefix: str, localName: str, namespaceURI: str, value: str) -> None: ...
    def IsDescendant(self, nav: XPathNavigator) -> bool: ...
    @abc.abstractmethod
    def IsSamePosition(self, other: XPathNavigator) -> bool: ...
    def LookupNamespace(self, prefix: str) -> str: ...
    def LookupPrefix(self, namespaceURI: str) -> str: ...
    @abc.abstractmethod
    def MoveTo(self, other: XPathNavigator) -> bool: ...
    def MoveToAttribute(self, localName: str, namespaceURI: str) -> bool: ...
    def MoveToFirst(self) -> bool: ...
    @abc.abstractmethod
    def MoveToFirstAttribute(self) -> bool: ...
    @abc.abstractmethod
    def MoveToFirstChild(self) -> bool: ...
    @abc.abstractmethod
    def MoveToId(self, id: str) -> bool: ...
    def MoveToNamespace(self, name: str) -> bool: ...
    @abc.abstractmethod
    def MoveToNextAttribute(self) -> bool: ...
    @abc.abstractmethod
    def MoveToParent(self) -> bool: ...
    @abc.abstractmethod
    def MoveToPrevious(self) -> bool: ...
    def MoveToRoot(self) -> None: ...
    def PrependChildElement(self, prefix: str, localName: str, namespaceURI: str, value: str) -> None: ...
    def ReadSubtree(self) -> XmlReader: ...
    def ReplaceRange(self, lastSiblingToReplace: XPathNavigator) -> XmlWriter: ...
    def SetTypedValue(self, typedValue: typing.Any) -> None: ...
    def SetValue(self, value: str) -> None: ...
    def ToString(self) -> str: ...
    def ValueAs(self, returnType: typing.Type[typing.Any], nsResolver: IXmlNamespaceResolver) -> typing.Any: ...
    def WriteSubtree(self, writer: XmlWriter) -> None: ...
    # Skipped AppendChild due to it being static, abstract and generic.

    AppendChild : AppendChild_MethodGroup
    class AppendChild_MethodGroup:
        @typing.overload
        def __call__(self) -> XmlWriter:...
        @typing.overload
        def __call__(self, newChild: str) -> None:...
        @typing.overload
        def __call__(self, newChild: XPathNavigator) -> None:...
        @typing.overload
        def __call__(self, newChild: XmlReader) -> None:...

    # Skipped Evaluate due to it being static, abstract and generic.

    Evaluate : Evaluate_MethodGroup
    class Evaluate_MethodGroup:
        @typing.overload
        def __call__(self, xpath: str) -> typing.Any:...
        @typing.overload
        def __call__(self, expr: XPathExpression) -> typing.Any:...
        @typing.overload
        def __call__(self, xpath: str, resolver: IXmlNamespaceResolver) -> typing.Any:...
        @typing.overload
        def __call__(self, expr: XPathExpression, context: XPathNodeIterator) -> typing.Any:...

    # Skipped InsertAfter due to it being static, abstract and generic.

    InsertAfter : InsertAfter_MethodGroup
    class InsertAfter_MethodGroup:
        @typing.overload
        def __call__(self) -> XmlWriter:...
        @typing.overload
        def __call__(self, newSibling: str) -> None:...
        @typing.overload
        def __call__(self, newSibling: XPathNavigator) -> None:...
        @typing.overload
        def __call__(self, newSibling: XmlReader) -> None:...

    # Skipped InsertBefore due to it being static, abstract and generic.

    InsertBefore : InsertBefore_MethodGroup
    class InsertBefore_MethodGroup:
        @typing.overload
        def __call__(self) -> XmlWriter:...
        @typing.overload
        def __call__(self, newSibling: str) -> None:...
        @typing.overload
        def __call__(self, newSibling: XPathNavigator) -> None:...
        @typing.overload
        def __call__(self, newSibling: XmlReader) -> None:...

    # Skipped Matches due to it being static, abstract and generic.

    Matches : Matches_MethodGroup
    class Matches_MethodGroup:
        @typing.overload
        def __call__(self, xpath: str) -> bool:...
        @typing.overload
        def __call__(self, expr: XPathExpression) -> bool:...

    # Skipped MoveToChild due to it being static, abstract and generic.

    MoveToChild : MoveToChild_MethodGroup
    class MoveToChild_MethodGroup:
        @typing.overload
        def __call__(self, type: XPathNodeType) -> bool:...
        @typing.overload
        def __call__(self, localName: str, namespaceURI: str) -> bool:...

    # Skipped MoveToFirstNamespace due to it being static, abstract and generic.

    MoveToFirstNamespace : MoveToFirstNamespace_MethodGroup
    class MoveToFirstNamespace_MethodGroup:
        @typing.overload
        def __call__(self) -> bool:...
        @typing.overload
        def __call__(self, namespaceScope: XPathNamespaceScope) -> bool:...

    # Skipped MoveToFollowing due to it being static, abstract and generic.

    MoveToFollowing : MoveToFollowing_MethodGroup
    class MoveToFollowing_MethodGroup:
        @typing.overload
        def __call__(self, type: XPathNodeType) -> bool:...
        @typing.overload
        def __call__(self, type: XPathNodeType, end: XPathNavigator) -> bool:...
        @typing.overload
        def __call__(self, localName: str, namespaceURI: str) -> bool:...
        @typing.overload
        def __call__(self, localName: str, namespaceURI: str, end: XPathNavigator) -> bool:...

    # Skipped MoveToNext due to it being static, abstract and generic.

    MoveToNext : MoveToNext_MethodGroup
    class MoveToNext_MethodGroup:
        @typing.overload
        def __call__(self) -> bool:...
        @typing.overload
        def __call__(self, type: XPathNodeType) -> bool:...
        @typing.overload
        def __call__(self, localName: str, namespaceURI: str) -> bool:...

    # Skipped MoveToNextNamespace due to it being static, abstract and generic.

    MoveToNextNamespace : MoveToNextNamespace_MethodGroup
    class MoveToNextNamespace_MethodGroup:
        @typing.overload
        def __call__(self) -> bool:...
        @typing.overload
        def __call__(self, namespaceScope: XPathNamespaceScope) -> bool:...

    # Skipped PrependChild due to it being static, abstract and generic.

    PrependChild : PrependChild_MethodGroup
    class PrependChild_MethodGroup:
        @typing.overload
        def __call__(self) -> XmlWriter:...
        @typing.overload
        def __call__(self, newChild: str) -> None:...
        @typing.overload
        def __call__(self, newChild: XPathNavigator) -> None:...
        @typing.overload
        def __call__(self, newChild: XmlReader) -> None:...

    # Skipped ReplaceSelf due to it being static, abstract and generic.

    ReplaceSelf : ReplaceSelf_MethodGroup
    class ReplaceSelf_MethodGroup:
        @typing.overload
        def __call__(self, newNode: str) -> None:...
        @typing.overload
        def __call__(self, newNode: XPathNavigator) -> None:...
        @typing.overload
        def __call__(self, newNode: XmlReader) -> None:...

    # Skipped Select due to it being static, abstract and generic.

    Select : Select_MethodGroup
    class Select_MethodGroup:
        @typing.overload
        def __call__(self, xpath: str) -> XPathNodeIterator:...
        @typing.overload
        def __call__(self, expr: XPathExpression) -> XPathNodeIterator:...
        @typing.overload
        def __call__(self, xpath: str, resolver: IXmlNamespaceResolver) -> XPathNodeIterator:...

    # Skipped SelectAncestors due to it being static, abstract and generic.

    SelectAncestors : SelectAncestors_MethodGroup
    class SelectAncestors_MethodGroup:
        @typing.overload
        def __call__(self, type: XPathNodeType, matchSelf: bool) -> XPathNodeIterator:...
        @typing.overload
        def __call__(self, name: str, namespaceURI: str, matchSelf: bool) -> XPathNodeIterator:...

    # Skipped SelectChildren due to it being static, abstract and generic.

    SelectChildren : SelectChildren_MethodGroup
    class SelectChildren_MethodGroup:
        @typing.overload
        def __call__(self, type: XPathNodeType) -> XPathNodeIterator:...
        @typing.overload
        def __call__(self, name: str, namespaceURI: str) -> XPathNodeIterator:...

    # Skipped SelectDescendants due to it being static, abstract and generic.

    SelectDescendants : SelectDescendants_MethodGroup
    class SelectDescendants_MethodGroup:
        @typing.overload
        def __call__(self, type: XPathNodeType, matchSelf: bool) -> XPathNodeIterator:...
        @typing.overload
        def __call__(self, name: str, namespaceURI: str, matchSelf: bool) -> XPathNodeIterator:...

    # Skipped SelectSingleNode due to it being static, abstract and generic.

    SelectSingleNode : SelectSingleNode_MethodGroup
    class SelectSingleNode_MethodGroup:
        @typing.overload
        def __call__(self, xpath: str) -> XPathNavigator:...
        @typing.overload
        def __call__(self, expression: XPathExpression) -> XPathNavigator:...
        @typing.overload
        def __call__(self, xpath: str, resolver: IXmlNamespaceResolver) -> XPathNavigator:...



class XPathNodeIterator(IEnumerable, ICloneable, abc.ABC):
    @property
    def Count(self) -> int: ...
    @property
    def Current(self) -> XPathNavigator: ...
    @property
    def CurrentPosition(self) -> int: ...
    @abc.abstractmethod
    def Clone(self) -> XPathNodeIterator: ...
    def GetEnumerator(self) -> IEnumerator: ...
    @abc.abstractmethod
    def MoveNext(self) -> bool: ...


class XPathNodeType(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Root : XPathNodeType # 0
    Element : XPathNodeType # 1
    Attribute : XPathNodeType # 2
    Namespace : XPathNodeType # 3
    Text : XPathNodeType # 4
    SignificantWhitespace : XPathNodeType # 5
    Whitespace : XPathNodeType # 6
    ProcessingInstruction : XPathNodeType # 7
    Comment : XPathNodeType # 8
    All : XPathNodeType # 9


class XPathResultType(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Number : XPathResultType # 0
    String : XPathResultType # 1
    Navigator : XPathResultType # 1
    Boolean : XPathResultType # 2
    NodeSet : XPathResultType # 3
    Any : XPathResultType # 5
    Error : XPathResultType # 6

