import typing, abc
from System.Collections import ICollection, IEnumerator, ReadOnlyCollectionBase, IList, IComparer, IEnumerable, IDictionary
from System import Array, Array_1, Attribute, Delegate, IDisposable, IServiceProvider, EventHandler, Exception
from System.Globalization import CultureInfo
from System.Runtime.InteropServices import ExternalException
from System.Reflection import MethodBase
from System.Runtime.Serialization import SerializationInfo, StreamingContext

class AttributeCollection(ICollection):
    def __init__(self, attributes: Array_1[Attribute]) -> None: ...
    Empty : AttributeCollection
    @property
    def Count(self) -> int: ...
    @property
    def Item(self) -> Attribute: ...
    @property
    def Item(self) -> Attribute: ...
    def CopyTo(self, array: Array, index: int) -> None: ...
    @staticmethod
    def FromExisting(existing: AttributeCollection, newAttributes: Array_1[Attribute]) -> AttributeCollection: ...
    def GetEnumerator(self) -> IEnumerator: ...
    # Skipped Contains due to it being static, abstract and generic.

    Contains : Contains_MethodGroup
    class Contains_MethodGroup:
        @typing.overload
        def __call__(self, attributes: Array_1[Attribute]) -> bool:...
        @typing.overload
        def __call__(self, attribute: Attribute) -> bool:...

    # Skipped Matches due to it being static, abstract and generic.

    Matches : Matches_MethodGroup
    class Matches_MethodGroup:
        @typing.overload
        def __call__(self, attributes: Array_1[Attribute]) -> bool:...
        @typing.overload
        def __call__(self, attribute: Attribute) -> bool:...



class ComponentCollection(ReadOnlyCollectionBase):
    def __init__(self, components: Array_1[IComponent]) -> None: ...
    @property
    def Count(self) -> int: ...
    @property
    def Item(self) -> IComponent: ...
    @property
    def Item(self) -> IComponent: ...
    def CopyTo(self, array: Array_1[IComponent], index: int) -> None: ...


class DefaultValueAttribute(Attribute):
    # Constructor .ctor(value : Int16) was skipped since it collides with above method
    # Constructor .ctor(value : Int32) was skipped since it collides with above method
    # Constructor .ctor(value : Int64) was skipped since it collides with above method
    # Constructor .ctor(value : Single) was skipped since it collides with above method
    # Constructor .ctor(value : Double) was skipped since it collides with above method
    # Constructor .ctor(value : Boolean) was skipped since it collides with above method
    # Constructor .ctor(value : String) was skipped since it collides with above method
    # Constructor .ctor(value : SByte) was skipped since it collides with above method
    # Constructor .ctor(value : UInt16) was skipped since it collides with above method
    # Constructor .ctor(value : UInt32) was skipped since it collides with above method
    # Constructor .ctor(value : UInt64) was skipped since it collides with above method
    @typing.overload
    def __init__(self, type: typing.Type[typing.Any], value: str) -> None: ...
    @typing.overload
    def __init__(self, value: str) -> None: ...
    @typing.overload
    def __init__(self, value: int) -> None: ...
    @typing.overload
    def __init__(self, value: typing.Any) -> None: ...
    @property
    def TypeId(self) -> typing.Any: ...
    @property
    def Value(self) -> typing.Any: ...
    def Equals(self, obj: typing.Any) -> bool: ...
    def GetHashCode(self) -> int: ...


class DesignerSerializationVisibility(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Hidden : DesignerSerializationVisibility # 0
    Visible : DesignerSerializationVisibility # 1
    Content : DesignerSerializationVisibility # 2


class EditorBrowsableAttribute(Attribute):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, state: EditorBrowsableState) -> None: ...
    @property
    def State(self) -> EditorBrowsableState: ...
    @property
    def TypeId(self) -> typing.Any: ...
    def Equals(self, obj: typing.Any) -> bool: ...
    def GetHashCode(self) -> int: ...


class EditorBrowsableState(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Always : EditorBrowsableState # 0
    Never : EditorBrowsableState # 1
    Advanced : EditorBrowsableState # 2


class EventDescriptor(MemberDescriptor):
    @property
    def Attributes(self) -> AttributeCollection: ...
    @property
    def Category(self) -> str: ...
    @property
    def ComponentType(self) -> typing.Type[typing.Any]: ...
    @property
    def Description(self) -> str: ...
    @property
    def DesignTimeOnly(self) -> bool: ...
    @property
    def DisplayName(self) -> str: ...
    @property
    def EventType(self) -> typing.Type[typing.Any]: ...
    @property
    def IsBrowsable(self) -> bool: ...
    @property
    def IsMulticast(self) -> bool: ...
    @property
    def Name(self) -> str: ...
    @abc.abstractmethod
    def AddEventHandler(self, component: typing.Any, value: Delegate) -> None: ...
    @abc.abstractmethod
    def RemoveEventHandler(self, component: typing.Any, value: Delegate) -> None: ...


class EventDescriptorCollection(IList):
    @typing.overload
    def __init__(self, events: Array_1[EventDescriptor]) -> None: ...
    @typing.overload
    def __init__(self, events: Array_1[EventDescriptor], readOnly: bool) -> None: ...
    Empty : EventDescriptorCollection
    @property
    def Count(self) -> int: ...
    @Count.setter
    def Count(self, value: int) -> int: ...
    @property
    def Item(self) -> EventDescriptor: ...
    @property
    def Item(self) -> EventDescriptor: ...
    def Add(self, value: EventDescriptor) -> int: ...
    def Clear(self) -> None: ...
    def Contains(self, value: EventDescriptor) -> bool: ...
    def Find(self, name: str, ignoreCase: bool) -> EventDescriptor: ...
    def GetEnumerator(self) -> IEnumerator: ...
    def IndexOf(self, value: EventDescriptor) -> int: ...
    def Insert(self, index: int, value: EventDescriptor) -> None: ...
    def Remove(self, value: EventDescriptor) -> None: ...
    def RemoveAt(self, index: int) -> None: ...
    # Skipped Sort due to it being static, abstract and generic.

    Sort : Sort_MethodGroup
    class Sort_MethodGroup:
        @typing.overload
        def __call__(self) -> EventDescriptorCollection:...
        @typing.overload
        def __call__(self, names: Array_1[str]) -> EventDescriptorCollection:...
        @typing.overload
        def __call__(self, comparer: IComparer) -> EventDescriptorCollection:...
        @typing.overload
        def __call__(self, names: Array_1[str], comparer: IComparer) -> EventDescriptorCollection:...



class IBindingList(IList, typing.Protocol):
    @property
    def AllowEdit(self) -> bool: ...
    @property
    def AllowNew(self) -> bool: ...
    @property
    def AllowRemove(self) -> bool: ...
    @property
    def IsSorted(self) -> bool: ...
    @property
    def SortDirection(self) -> ListSortDirection: ...
    @property
    def SortProperty(self) -> PropertyDescriptor: ...
    @property
    def SupportsChangeNotification(self) -> bool: ...
    @property
    def SupportsSearching(self) -> bool: ...
    @property
    def SupportsSorting(self) -> bool: ...
    @abc.abstractmethod
    def AddIndex(self, property: PropertyDescriptor) -> None: ...
    @abc.abstractmethod
    def AddNew(self) -> typing.Any: ...
    @abc.abstractmethod
    def ApplySort(self, property: PropertyDescriptor, direction: ListSortDirection) -> None: ...
    @abc.abstractmethod
    def Find(self, property: PropertyDescriptor, key: typing.Any) -> int: ...
    @abc.abstractmethod
    def RemoveIndex(self, property: PropertyDescriptor) -> None: ...
    @abc.abstractmethod
    def RemoveSort(self) -> None: ...


class IComponent(IDisposable, typing.Protocol):
    @property
    def Site(self) -> ISite: ...
    @Site.setter
    def Site(self, value: ISite) -> ISite: ...


class IContainer(IDisposable, typing.Protocol):
    @property
    def Components(self) -> ComponentCollection: ...
    @abc.abstractmethod
    def Remove(self, component: IComponent) -> None: ...
    # Skipped Add due to it being static, abstract and generic.

    Add : Add_MethodGroup
    class Add_MethodGroup:
        @typing.overload
        def __call__(self, component: IComponent) -> None:...
        @typing.overload
        def __call__(self, component: IComponent, name: str) -> None:...



class ICustomTypeDescriptor(typing.Protocol):
    @abc.abstractmethod
    def GetAttributes(self) -> AttributeCollection: ...
    @abc.abstractmethod
    def GetClassName(self) -> str: ...
    @abc.abstractmethod
    def GetComponentName(self) -> str: ...
    @abc.abstractmethod
    def GetConverter(self) -> TypeConverter: ...
    @abc.abstractmethod
    def GetDefaultEvent(self) -> EventDescriptor: ...
    @abc.abstractmethod
    def GetDefaultProperty(self) -> PropertyDescriptor: ...
    @abc.abstractmethod
    def GetEditor(self, editorBaseType: typing.Type[typing.Any]) -> typing.Any: ...
    @abc.abstractmethod
    def GetPropertyOwner(self, pd: PropertyDescriptor) -> typing.Any: ...
    # Skipped GetEvents due to it being static, abstract and generic.

    GetEvents : GetEvents_MethodGroup
    class GetEvents_MethodGroup:
        @typing.overload
        def __call__(self) -> EventDescriptorCollection:...
        @typing.overload
        def __call__(self, attributes: Array_1[Attribute]) -> EventDescriptorCollection:...

    # Skipped GetProperties due to it being static, abstract and generic.

    GetProperties : GetProperties_MethodGroup
    class GetProperties_MethodGroup:
        @typing.overload
        def __call__(self) -> PropertyDescriptorCollection:...
        @typing.overload
        def __call__(self, attributes: Array_1[Attribute]) -> PropertyDescriptorCollection:...



class INotifyDataErrorInfo(typing.Protocol):
    @property
    def HasErrors(self) -> bool: ...
    @abc.abstractmethod
    def GetErrors(self, propertyName: str) -> IEnumerable: ...


class INotifyPropertyChanged(typing.Protocol):
    pass


class INotifyPropertyChanging(typing.Protocol):
    pass


class ISite(IServiceProvider, typing.Protocol):
    @property
    def Component(self) -> IComponent: ...
    @property
    def Container(self) -> IContainer: ...
    @property
    def DesignMode(self) -> bool: ...
    @property
    def Name(self) -> str: ...
    @Name.setter
    def Name(self, value: str) -> str: ...


class ITypeDescriptorContext(IServiceProvider, typing.Protocol):
    @property
    def Container(self) -> IContainer: ...
    @property
    def Instance(self) -> typing.Any: ...
    @property
    def PropertyDescriptor(self) -> PropertyDescriptor: ...
    @abc.abstractmethod
    def OnComponentChanged(self) -> None: ...
    @abc.abstractmethod
    def OnComponentChanging(self) -> bool: ...


class ITypedList(typing.Protocol):
    @abc.abstractmethod
    def GetItemProperties(self, listAccessors: Array_1[PropertyDescriptor]) -> PropertyDescriptorCollection: ...
    @abc.abstractmethod
    def GetListName(self, listAccessors: Array_1[PropertyDescriptor]) -> str: ...


class ListSortDirection(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Ascending : ListSortDirection # 0
    Descending : ListSortDirection # 1


class MemberDescriptor(abc.ABC):
    @property
    def Attributes(self) -> AttributeCollection: ...
    @property
    def Category(self) -> str: ...
    @property
    def Description(self) -> str: ...
    @property
    def DesignTimeOnly(self) -> bool: ...
    @property
    def DisplayName(self) -> str: ...
    @property
    def IsBrowsable(self) -> bool: ...
    @property
    def Name(self) -> str: ...
    def Equals(self, obj: typing.Any) -> bool: ...
    def GetHashCode(self) -> int: ...


class PropertyDescriptor(MemberDescriptor):
    @property
    def Attributes(self) -> AttributeCollection: ...
    @property
    def Category(self) -> str: ...
    @property
    def ComponentType(self) -> typing.Type[typing.Any]: ...
    @property
    def Converter(self) -> TypeConverter: ...
    @property
    def Description(self) -> str: ...
    @property
    def DesignTimeOnly(self) -> bool: ...
    @property
    def DisplayName(self) -> str: ...
    @property
    def IsBrowsable(self) -> bool: ...
    @property
    def IsLocalizable(self) -> bool: ...
    @property
    def IsReadOnly(self) -> bool: ...
    @property
    def Name(self) -> str: ...
    @property
    def PropertyType(self) -> typing.Type[typing.Any]: ...
    @property
    def SerializationVisibility(self) -> DesignerSerializationVisibility: ...
    @property
    def SupportsChangeEvents(self) -> bool: ...
    def AddValueChanged(self, component: typing.Any, handler: EventHandler) -> None: ...
    @abc.abstractmethod
    def CanResetValue(self, component: typing.Any) -> bool: ...
    def Equals(self, obj: typing.Any) -> bool: ...
    def GetEditor(self, editorBaseType: typing.Type[typing.Any]) -> typing.Any: ...
    def GetHashCode(self) -> int: ...
    @abc.abstractmethod
    def GetValue(self, component: typing.Any) -> typing.Any: ...
    def RemoveValueChanged(self, component: typing.Any, handler: EventHandler) -> None: ...
    @abc.abstractmethod
    def ResetValue(self, component: typing.Any) -> None: ...
    @abc.abstractmethod
    def SetValue(self, component: typing.Any, value: typing.Any) -> None: ...
    @abc.abstractmethod
    def ShouldSerializeValue(self, component: typing.Any) -> bool: ...
    # Skipped GetChildProperties due to it being static, abstract and generic.

    GetChildProperties : GetChildProperties_MethodGroup
    class GetChildProperties_MethodGroup:
        @typing.overload
        def __call__(self) -> PropertyDescriptorCollection:...
        @typing.overload
        def __call__(self, filter: Array_1[Attribute]) -> PropertyDescriptorCollection:...
        @typing.overload
        def __call__(self, instance: typing.Any) -> PropertyDescriptorCollection:...
        @typing.overload
        def __call__(self, instance: typing.Any, filter: Array_1[Attribute]) -> PropertyDescriptorCollection:...



class PropertyDescriptorCollection(IDictionary, IList):
    @typing.overload
    def __init__(self, properties: Array_1[PropertyDescriptor]) -> None: ...
    @typing.overload
    def __init__(self, properties: Array_1[PropertyDescriptor], readOnly: bool) -> None: ...
    Empty : PropertyDescriptorCollection
    @property
    def Count(self) -> int: ...
    @Count.setter
    def Count(self, value: int) -> int: ...
    @property
    def Item(self) -> PropertyDescriptor: ...
    @property
    def Item(self) -> PropertyDescriptor: ...
    def Add(self, value: PropertyDescriptor) -> int: ...
    def Clear(self) -> None: ...
    def Contains(self, value: PropertyDescriptor) -> bool: ...
    def CopyTo(self, array: Array, index: int) -> None: ...
    def Find(self, name: str, ignoreCase: bool) -> PropertyDescriptor: ...
    def GetEnumerator(self) -> IEnumerator: ...
    def IndexOf(self, value: PropertyDescriptor) -> int: ...
    def Insert(self, index: int, value: PropertyDescriptor) -> None: ...
    def Remove(self, value: PropertyDescriptor) -> None: ...
    def RemoveAt(self, index: int) -> None: ...
    # Skipped Sort due to it being static, abstract and generic.

    Sort : Sort_MethodGroup
    class Sort_MethodGroup:
        @typing.overload
        def __call__(self) -> PropertyDescriptorCollection:...
        @typing.overload
        def __call__(self, names: Array_1[str]) -> PropertyDescriptorCollection:...
        @typing.overload
        def __call__(self, comparer: IComparer) -> PropertyDescriptorCollection:...
        @typing.overload
        def __call__(self, names: Array_1[str], comparer: IComparer) -> PropertyDescriptorCollection:...



class TypeConverter:
    def __init__(self) -> None: ...
    # Skipped CanConvertFrom due to it being static, abstract and generic.

    CanConvertFrom : CanConvertFrom_MethodGroup
    class CanConvertFrom_MethodGroup:
        @typing.overload
        def __call__(self, sourceType: typing.Type[typing.Any]) -> bool:...
        @typing.overload
        def __call__(self, context: ITypeDescriptorContext, sourceType: typing.Type[typing.Any]) -> bool:...

    # Skipped CanConvertTo due to it being static, abstract and generic.

    CanConvertTo : CanConvertTo_MethodGroup
    class CanConvertTo_MethodGroup:
        @typing.overload
        def __call__(self, destinationType: typing.Type[typing.Any]) -> bool:...
        @typing.overload
        def __call__(self, context: ITypeDescriptorContext, destinationType: typing.Type[typing.Any]) -> bool:...

    # Skipped ConvertFrom due to it being static, abstract and generic.

    ConvertFrom : ConvertFrom_MethodGroup
    class ConvertFrom_MethodGroup:
        @typing.overload
        def __call__(self, value: typing.Any) -> typing.Any:...
        @typing.overload
        def __call__(self, context: ITypeDescriptorContext, culture: CultureInfo, value: typing.Any) -> typing.Any:...

    # Skipped ConvertFromInvariantString due to it being static, abstract and generic.

    ConvertFromInvariantString : ConvertFromInvariantString_MethodGroup
    class ConvertFromInvariantString_MethodGroup:
        @typing.overload
        def __call__(self, text: str) -> typing.Any:...
        @typing.overload
        def __call__(self, context: ITypeDescriptorContext, text: str) -> typing.Any:...

    # Skipped ConvertFromString due to it being static, abstract and generic.

    ConvertFromString : ConvertFromString_MethodGroup
    class ConvertFromString_MethodGroup:
        @typing.overload
        def __call__(self, text: str) -> typing.Any:...
        @typing.overload
        def __call__(self, context: ITypeDescriptorContext, text: str) -> typing.Any:...
        @typing.overload
        def __call__(self, context: ITypeDescriptorContext, culture: CultureInfo, text: str) -> typing.Any:...

    # Skipped ConvertTo due to it being static, abstract and generic.

    ConvertTo : ConvertTo_MethodGroup
    class ConvertTo_MethodGroup:
        @typing.overload
        def __call__(self, value: typing.Any, destinationType: typing.Type[typing.Any]) -> typing.Any:...
        @typing.overload
        def __call__(self, context: ITypeDescriptorContext, culture: CultureInfo, value: typing.Any, destinationType: typing.Type[typing.Any]) -> typing.Any:...

    # Skipped ConvertToInvariantString due to it being static, abstract and generic.

    ConvertToInvariantString : ConvertToInvariantString_MethodGroup
    class ConvertToInvariantString_MethodGroup:
        @typing.overload
        def __call__(self, value: typing.Any) -> str:...
        @typing.overload
        def __call__(self, context: ITypeDescriptorContext, value: typing.Any) -> str:...

    # Skipped ConvertToString due to it being static, abstract and generic.

    ConvertToString : ConvertToString_MethodGroup
    class ConvertToString_MethodGroup:
        @typing.overload
        def __call__(self, value: typing.Any) -> str:...
        @typing.overload
        def __call__(self, context: ITypeDescriptorContext, value: typing.Any) -> str:...
        @typing.overload
        def __call__(self, context: ITypeDescriptorContext, culture: CultureInfo, value: typing.Any) -> str:...

    # Skipped CreateInstance due to it being static, abstract and generic.

    CreateInstance : CreateInstance_MethodGroup
    class CreateInstance_MethodGroup:
        @typing.overload
        def __call__(self, propertyValues: IDictionary) -> typing.Any:...
        @typing.overload
        def __call__(self, context: ITypeDescriptorContext, propertyValues: IDictionary) -> typing.Any:...

    # Skipped GetCreateInstanceSupported due to it being static, abstract and generic.

    GetCreateInstanceSupported : GetCreateInstanceSupported_MethodGroup
    class GetCreateInstanceSupported_MethodGroup:
        @typing.overload
        def __call__(self) -> bool:...
        @typing.overload
        def __call__(self, context: ITypeDescriptorContext) -> bool:...

    # Skipped GetProperties due to it being static, abstract and generic.

    GetProperties : GetProperties_MethodGroup
    class GetProperties_MethodGroup:
        @typing.overload
        def __call__(self, value: typing.Any) -> PropertyDescriptorCollection:...
        @typing.overload
        def __call__(self, context: ITypeDescriptorContext, value: typing.Any) -> PropertyDescriptorCollection:...
        @typing.overload
        def __call__(self, context: ITypeDescriptorContext, value: typing.Any, attributes: Array_1[Attribute]) -> PropertyDescriptorCollection:...

    # Skipped GetPropertiesSupported due to it being static, abstract and generic.

    GetPropertiesSupported : GetPropertiesSupported_MethodGroup
    class GetPropertiesSupported_MethodGroup:
        @typing.overload
        def __call__(self) -> bool:...
        @typing.overload
        def __call__(self, context: ITypeDescriptorContext) -> bool:...

    # Skipped GetStandardValues due to it being static, abstract and generic.

    GetStandardValues : GetStandardValues_MethodGroup
    class GetStandardValues_MethodGroup:
        @typing.overload
        def __call__(self) -> ICollection:...
        @typing.overload
        def __call__(self, context: ITypeDescriptorContext) -> TypeConverter.StandardValuesCollection:...

    # Skipped GetStandardValuesExclusive due to it being static, abstract and generic.

    GetStandardValuesExclusive : GetStandardValuesExclusive_MethodGroup
    class GetStandardValuesExclusive_MethodGroup:
        @typing.overload
        def __call__(self) -> bool:...
        @typing.overload
        def __call__(self, context: ITypeDescriptorContext) -> bool:...

    # Skipped GetStandardValuesSupported due to it being static, abstract and generic.

    GetStandardValuesSupported : GetStandardValuesSupported_MethodGroup
    class GetStandardValuesSupported_MethodGroup:
        @typing.overload
        def __call__(self) -> bool:...
        @typing.overload
        def __call__(self, context: ITypeDescriptorContext) -> bool:...

    # Skipped IsValid due to it being static, abstract and generic.

    IsValid : IsValid_MethodGroup
    class IsValid_MethodGroup:
        @typing.overload
        def __call__(self, value: typing.Any) -> bool:...
        @typing.overload
        def __call__(self, context: ITypeDescriptorContext, value: typing.Any) -> bool:...


    class StandardValuesCollection(ICollection):
        def __init__(self, values: ICollection) -> None: ...
        @property
        def Count(self) -> int: ...
        @property
        def Item(self) -> typing.Any: ...
        def CopyTo(self, array: Array, index: int) -> None: ...
        def GetEnumerator(self) -> IEnumerator: ...



class Win32Exception(ExternalException):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, error: int) -> None: ...
    @typing.overload
    def __init__(self, error: int, message: str) -> None: ...
    @typing.overload
    def __init__(self, message: str) -> None: ...
    @typing.overload
    def __init__(self, message: str, innerException: Exception) -> None: ...
    @property
    def Data(self) -> IDictionary: ...
    @property
    def ErrorCode(self) -> int: ...
    @property
    def HelpLink(self) -> str: ...
    @HelpLink.setter
    def HelpLink(self, value: str) -> str: ...
    @property
    def HResult(self) -> int: ...
    @HResult.setter
    def HResult(self, value: int) -> int: ...
    @property
    def InnerException(self) -> Exception: ...
    @property
    def Message(self) -> str: ...
    @property
    def NativeErrorCode(self) -> int: ...
    @property
    def Source(self) -> str: ...
    @Source.setter
    def Source(self, value: str) -> str: ...
    @property
    def StackTrace(self) -> str: ...
    @property
    def TargetSite(self) -> MethodBase: ...
    def GetObjectData(self, info: SerializationInfo, context: StreamingContext) -> None: ...
    def ToString(self) -> str: ...

