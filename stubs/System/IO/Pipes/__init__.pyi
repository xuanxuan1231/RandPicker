import typing
from Microsoft.Win32.SafeHandles import SafePipeHandle
from System.Security.Principal import TokenImpersonationLevel
from System.IO import HandleInheritability, Stream, SeekOrigin
from System import TimeSpan, IAsyncResult, Array_1, AsyncCallback, Span_1, Memory_1, ReadOnlySpan_1, ReadOnlyMemory_1
from System.Threading.Tasks import Task, ValueTask_1, Task_1, ValueTask
from System.Threading import CancellationToken

class NamedPipeClientStream(PipeStream):
    @typing.overload
    def __init__(self, direction: PipeDirection, isAsync: bool, isConnected: bool, safePipeHandle: SafePipeHandle) -> None: ...
    @typing.overload
    def __init__(self, pipeName: str) -> None: ...
    @typing.overload
    def __init__(self, serverName: str, pipeName: str) -> None: ...
    @typing.overload
    def __init__(self, serverName: str, pipeName: str, direction: PipeDirection) -> None: ...
    @typing.overload
    def __init__(self, serverName: str, pipeName: str, direction: PipeDirection, options: PipeOptions) -> None: ...
    @typing.overload
    def __init__(self, serverName: str, pipeName: str, direction: PipeDirection, options: PipeOptions, impersonationLevel: TokenImpersonationLevel) -> None: ...
    @typing.overload
    def __init__(self, serverName: str, pipeName: str, direction: PipeDirection, options: PipeOptions, impersonationLevel: TokenImpersonationLevel, inheritability: HandleInheritability) -> None: ...
    @property
    def CanRead(self) -> bool: ...
    @property
    def CanSeek(self) -> bool: ...
    @property
    def CanTimeout(self) -> bool: ...
    @property
    def CanWrite(self) -> bool: ...
    @property
    def InBufferSize(self) -> int: ...
    @property
    def IsAsync(self) -> bool: ...
    @property
    def IsConnected(self) -> bool: ...
    @IsConnected.setter
    def IsConnected(self, value: bool) -> bool: ...
    @property
    def IsMessageComplete(self) -> bool: ...
    @property
    def Length(self) -> int: ...
    @property
    def NumberOfServerInstances(self) -> int: ...
    @property
    def OutBufferSize(self) -> int: ...
    @property
    def Position(self) -> int: ...
    @Position.setter
    def Position(self, value: int) -> int: ...
    @property
    def ReadMode(self) -> PipeTransmissionMode: ...
    @ReadMode.setter
    def ReadMode(self, value: PipeTransmissionMode) -> PipeTransmissionMode: ...
    @property
    def ReadTimeout(self) -> int: ...
    @ReadTimeout.setter
    def ReadTimeout(self, value: int) -> int: ...
    @property
    def SafePipeHandle(self) -> SafePipeHandle: ...
    @property
    def TransmissionMode(self) -> PipeTransmissionMode: ...
    @property
    def WriteTimeout(self) -> int: ...
    @WriteTimeout.setter
    def WriteTimeout(self, value: int) -> int: ...
    # Skipped Connect due to it being static, abstract and generic.

    Connect : Connect_MethodGroup
    class Connect_MethodGroup:
        @typing.overload
        def __call__(self) -> None:...
        @typing.overload
        def __call__(self, timeout: int) -> None:...
        @typing.overload
        def __call__(self, timeout: TimeSpan) -> None:...

    # Skipped ConnectAsync due to it being static, abstract and generic.

    ConnectAsync : ConnectAsync_MethodGroup
    class ConnectAsync_MethodGroup:
        @typing.overload
        def __call__(self) -> Task:...
        @typing.overload
        def __call__(self, timeout: int) -> Task:...
        @typing.overload
        def __call__(self, cancellationToken: CancellationToken) -> Task:...
        @typing.overload
        def __call__(self, timeout: int, cancellationToken: CancellationToken) -> Task:...
        @typing.overload
        def __call__(self, timeout: TimeSpan, cancellationToken: CancellationToken = ...) -> Task:...



class PipeDirection(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    In : PipeDirection # 1
    Out : PipeDirection # 2
    InOut : PipeDirection # 3


class PipeOptions(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    None_ : PipeOptions # 0
    FirstPipeInstance : PipeOptions # 524288
    CurrentUserOnly : PipeOptions # 536870912
    Asynchronous : PipeOptions # 1073741824
    WriteThrough : PipeOptions # -2147483648


class PipeStream(Stream):
    @property
    def CanRead(self) -> bool: ...
    @property
    def CanSeek(self) -> bool: ...
    @property
    def CanTimeout(self) -> bool: ...
    @property
    def CanWrite(self) -> bool: ...
    @property
    def InBufferSize(self) -> int: ...
    @property
    def IsAsync(self) -> bool: ...
    @property
    def IsConnected(self) -> bool: ...
    @IsConnected.setter
    def IsConnected(self, value: bool) -> bool: ...
    @property
    def IsMessageComplete(self) -> bool: ...
    @property
    def Length(self) -> int: ...
    @property
    def OutBufferSize(self) -> int: ...
    @property
    def Position(self) -> int: ...
    @Position.setter
    def Position(self, value: int) -> int: ...
    @property
    def ReadMode(self) -> PipeTransmissionMode: ...
    @ReadMode.setter
    def ReadMode(self, value: PipeTransmissionMode) -> PipeTransmissionMode: ...
    @property
    def ReadTimeout(self) -> int: ...
    @ReadTimeout.setter
    def ReadTimeout(self, value: int) -> int: ...
    @property
    def SafePipeHandle(self) -> SafePipeHandle: ...
    @property
    def TransmissionMode(self) -> PipeTransmissionMode: ...
    @property
    def WriteTimeout(self) -> int: ...
    @WriteTimeout.setter
    def WriteTimeout(self, value: int) -> int: ...
    def BeginRead(self, buffer: Array_1[int], offset: int, count: int, callback: AsyncCallback, state: typing.Any) -> IAsyncResult: ...
    def BeginWrite(self, buffer: Array_1[int], offset: int, count: int, callback: AsyncCallback, state: typing.Any) -> IAsyncResult: ...
    def EndRead(self, asyncResult: IAsyncResult) -> int: ...
    def EndWrite(self, asyncResult: IAsyncResult) -> None: ...
    def Flush(self) -> None: ...
    def FlushAsync(self, cancellationToken: CancellationToken) -> Task: ...
    def ReadByte(self) -> int: ...
    def Seek(self, offset: int, origin: SeekOrigin) -> int: ...
    def SetLength(self, value: int) -> None: ...
    def WaitForPipeDrain(self) -> None: ...
    def WriteByte(self, value: int) -> None: ...
    # Skipped Read due to it being static, abstract and generic.

    Read : Read_MethodGroup
    class Read_MethodGroup:
        @typing.overload
        def __call__(self, buffer: Span_1[int]) -> int:...
        @typing.overload
        def __call__(self, buffer: Array_1[int], offset: int, count: int) -> int:...

    # Skipped ReadAsync due to it being static, abstract and generic.

    ReadAsync : ReadAsync_MethodGroup
    class ReadAsync_MethodGroup:
        @typing.overload
        def __call__(self, buffer: Memory_1[int], cancellationToken: CancellationToken = ...) -> ValueTask_1[int]:...
        @typing.overload
        def __call__(self, buffer: Array_1[int], offset: int, count: int, cancellationToken: CancellationToken) -> Task_1[int]:...

    # Skipped Write due to it being static, abstract and generic.

    Write : Write_MethodGroup
    class Write_MethodGroup:
        @typing.overload
        def __call__(self, buffer: ReadOnlySpan_1[int]) -> None:...
        @typing.overload
        def __call__(self, buffer: Array_1[int], offset: int, count: int) -> None:...

    # Skipped WriteAsync due to it being static, abstract and generic.

    WriteAsync : WriteAsync_MethodGroup
    class WriteAsync_MethodGroup:
        @typing.overload
        def __call__(self, buffer: ReadOnlyMemory_1[int], cancellationToken: CancellationToken = ...) -> ValueTask:...
        @typing.overload
        def __call__(self, buffer: Array_1[int], offset: int, count: int, cancellationToken: CancellationToken) -> Task:...



class PipeTransmissionMode(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Byte : PipeTransmissionMode # 0
    Message : PipeTransmissionMode # 1

