import typing, abc
from System import Func_2, Func_1, Func_3, Predicate_1, Action, Action_1, Attribute
from System.Threading import CancellationToken
from System.Threading.Tasks import Task
from System.ComponentModel import INotifyPropertyChanged
from System.Windows.Input import ICommand

class AsyncRelayCommand_GenericClasses(abc.ABCMeta):
    Generic_AsyncRelayCommand_GenericClasses_AsyncRelayCommand_1_T = typing.TypeVar('Generic_AsyncRelayCommand_GenericClasses_AsyncRelayCommand_1_T')
    def __getitem__(self, types : typing.Type[Generic_AsyncRelayCommand_GenericClasses_AsyncRelayCommand_1_T]) -> typing.Type[AsyncRelayCommand_1[Generic_AsyncRelayCommand_GenericClasses_AsyncRelayCommand_1_T]]: ...

class AsyncRelayCommand(AsyncRelayCommand_0, metaclass =AsyncRelayCommand_GenericClasses): ...

class AsyncRelayCommand_0(IAsyncRelayCommand_0):
    @typing.overload
    def __init__(self, cancelableExecute: Func_2[CancellationToken, Task]) -> None: ...
    @typing.overload
    def __init__(self, cancelableExecute: Func_2[CancellationToken, Task], canExecute: Func_1[bool]) -> None: ...
    @typing.overload
    def __init__(self, cancelableExecute: Func_2[CancellationToken, Task], canExecute: Func_1[bool], options: AsyncRelayCommandOptions) -> None: ...
    @typing.overload
    def __init__(self, cancelableExecute: Func_2[CancellationToken, Task], options: AsyncRelayCommandOptions) -> None: ...
    @typing.overload
    def __init__(self, execute: Func_1[Task]) -> None: ...
    @typing.overload
    def __init__(self, execute: Func_1[Task], canExecute: Func_1[bool]) -> None: ...
    @typing.overload
    def __init__(self, execute: Func_1[Task], canExecute: Func_1[bool], options: AsyncRelayCommandOptions) -> None: ...
    @typing.overload
    def __init__(self, execute: Func_1[Task], options: AsyncRelayCommandOptions) -> None: ...
    @property
    def CanBeCanceled(self) -> bool: ...
    @property
    def ExecutionTask(self) -> Task: ...
    @ExecutionTask.setter
    def ExecutionTask(self, value: Task) -> Task: ...
    @property
    def IsCancellationRequested(self) -> bool: ...
    @property
    def IsRunning(self) -> bool: ...
    def Cancel(self) -> None: ...
    def CanExecute(self, parameter: typing.Any) -> bool: ...
    def Execute(self, parameter: typing.Any) -> None: ...
    def ExecuteAsync(self, parameter: typing.Any) -> Task: ...
    def NotifyCanExecuteChanged(self) -> None: ...


AsyncRelayCommand_1_T = typing.TypeVar('AsyncRelayCommand_1_T')
class AsyncRelayCommand_1(typing.Generic[AsyncRelayCommand_1_T], IAsyncRelayCommand_1[AsyncRelayCommand_1_T]):
    @typing.overload
    def __init__(self, cancelableExecute: Func_3[AsyncRelayCommand_1_T, CancellationToken, Task]) -> None: ...
    @typing.overload
    def __init__(self, cancelableExecute: Func_3[AsyncRelayCommand_1_T, CancellationToken, Task], canExecute: Predicate_1[AsyncRelayCommand_1_T]) -> None: ...
    @typing.overload
    def __init__(self, cancelableExecute: Func_3[AsyncRelayCommand_1_T, CancellationToken, Task], canExecute: Predicate_1[AsyncRelayCommand_1_T], options: AsyncRelayCommandOptions) -> None: ...
    @typing.overload
    def __init__(self, cancelableExecute: Func_3[AsyncRelayCommand_1_T, CancellationToken, Task], options: AsyncRelayCommandOptions) -> None: ...
    @typing.overload
    def __init__(self, execute: Func_2[AsyncRelayCommand_1_T, Task]) -> None: ...
    @typing.overload
    def __init__(self, execute: Func_2[AsyncRelayCommand_1_T, Task], canExecute: Predicate_1[AsyncRelayCommand_1_T]) -> None: ...
    @typing.overload
    def __init__(self, execute: Func_2[AsyncRelayCommand_1_T, Task], canExecute: Predicate_1[AsyncRelayCommand_1_T], options: AsyncRelayCommandOptions) -> None: ...
    @typing.overload
    def __init__(self, execute: Func_2[AsyncRelayCommand_1_T, Task], options: AsyncRelayCommandOptions) -> None: ...
    @property
    def CanBeCanceled(self) -> bool: ...
    @property
    def ExecutionTask(self) -> Task: ...
    @ExecutionTask.setter
    def ExecutionTask(self, value: Task) -> Task: ...
    @property
    def IsCancellationRequested(self) -> bool: ...
    @property
    def IsRunning(self) -> bool: ...
    def Cancel(self) -> None: ...
    def NotifyCanExecuteChanged(self) -> None: ...
    # Skipped CanExecute due to it being static, abstract and generic.

    CanExecute : CanExecute_MethodGroup[AsyncRelayCommand_1_T]
    CanExecute_MethodGroup_AsyncRelayCommand_1_T = typing.TypeVar('CanExecute_MethodGroup_AsyncRelayCommand_1_T')
    class CanExecute_MethodGroup(typing.Generic[CanExecute_MethodGroup_AsyncRelayCommand_1_T]):
        CanExecute_MethodGroup_AsyncRelayCommand_1_T = AsyncRelayCommand_1.CanExecute_MethodGroup_AsyncRelayCommand_1_T
        @typing.overload
        def __call__(self, parameter: CanExecute_MethodGroup_AsyncRelayCommand_1_T) -> bool:...
        @typing.overload
        def __call__(self, parameter: typing.Any) -> bool:...

    # Skipped Execute due to it being static, abstract and generic.

    Execute : Execute_MethodGroup[AsyncRelayCommand_1_T]
    Execute_MethodGroup_AsyncRelayCommand_1_T = typing.TypeVar('Execute_MethodGroup_AsyncRelayCommand_1_T')
    class Execute_MethodGroup(typing.Generic[Execute_MethodGroup_AsyncRelayCommand_1_T]):
        Execute_MethodGroup_AsyncRelayCommand_1_T = AsyncRelayCommand_1.Execute_MethodGroup_AsyncRelayCommand_1_T
        @typing.overload
        def __call__(self, parameter: Execute_MethodGroup_AsyncRelayCommand_1_T) -> None:...
        @typing.overload
        def __call__(self, parameter: typing.Any) -> None:...

    # Skipped ExecuteAsync due to it being static, abstract and generic.

    ExecuteAsync : ExecuteAsync_MethodGroup[AsyncRelayCommand_1_T]
    ExecuteAsync_MethodGroup_AsyncRelayCommand_1_T = typing.TypeVar('ExecuteAsync_MethodGroup_AsyncRelayCommand_1_T')
    class ExecuteAsync_MethodGroup(typing.Generic[ExecuteAsync_MethodGroup_AsyncRelayCommand_1_T]):
        ExecuteAsync_MethodGroup_AsyncRelayCommand_1_T = AsyncRelayCommand_1.ExecuteAsync_MethodGroup_AsyncRelayCommand_1_T
        @typing.overload
        def __call__(self, parameter: ExecuteAsync_MethodGroup_AsyncRelayCommand_1_T) -> Task:...
        @typing.overload
        def __call__(self, parameter: typing.Any) -> Task:...



class AsyncRelayCommandOptions(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    None_ : AsyncRelayCommandOptions # 0
    AllowConcurrentExecutions : AsyncRelayCommandOptions # 1
    FlowExceptionsToTaskScheduler : AsyncRelayCommandOptions # 2


class IAsyncRelayCommand_GenericClasses(abc.ABCMeta):
    Generic_IAsyncRelayCommand_GenericClasses_IAsyncRelayCommand_1_T = typing.TypeVar('Generic_IAsyncRelayCommand_GenericClasses_IAsyncRelayCommand_1_T')
    def __getitem__(self, types : typing.Type[Generic_IAsyncRelayCommand_GenericClasses_IAsyncRelayCommand_1_T]) -> typing.Type[IAsyncRelayCommand_1[Generic_IAsyncRelayCommand_GenericClasses_IAsyncRelayCommand_1_T]]: ...

class IAsyncRelayCommand(IAsyncRelayCommand_0, metaclass =IAsyncRelayCommand_GenericClasses): ...

class IAsyncRelayCommand_0(IRelayCommand_0, INotifyPropertyChanged, typing.Protocol):
    @property
    def CanBeCanceled(self) -> bool: ...
    @property
    def ExecutionTask(self) -> Task: ...
    @property
    def IsCancellationRequested(self) -> bool: ...
    @property
    def IsRunning(self) -> bool: ...
    @abc.abstractmethod
    def Cancel(self) -> None: ...
    @abc.abstractmethod
    def ExecuteAsync(self, parameter: typing.Any) -> Task: ...


IAsyncRelayCommand_1_T = typing.TypeVar('IAsyncRelayCommand_1_T', contravariant=True)
class IAsyncRelayCommand_1(typing.Generic[IAsyncRelayCommand_1_T], IRelayCommand_1[IAsyncRelayCommand_1_T], IAsyncRelayCommand_0, typing.Protocol):
    @abc.abstractmethod
    def ExecuteAsync(self, parameter: IAsyncRelayCommand_1_T) -> Task: ...


class IAsyncRelayCommandExtensions(abc.ABC):
    @staticmethod
    def CreateCancelCommand(command: IAsyncRelayCommand) -> ICommand: ...


class IRelayCommand_GenericClasses(abc.ABCMeta):
    Generic_IRelayCommand_GenericClasses_IRelayCommand_1_T = typing.TypeVar('Generic_IRelayCommand_GenericClasses_IRelayCommand_1_T')
    def __getitem__(self, types : typing.Type[Generic_IRelayCommand_GenericClasses_IRelayCommand_1_T]) -> typing.Type[IRelayCommand_1[Generic_IRelayCommand_GenericClasses_IRelayCommand_1_T]]: ...

class IRelayCommand(IRelayCommand_0, metaclass =IRelayCommand_GenericClasses): ...

class IRelayCommand_0(ICommand, typing.Protocol):
    @abc.abstractmethod
    def NotifyCanExecuteChanged(self) -> None: ...


IRelayCommand_1_T = typing.TypeVar('IRelayCommand_1_T', contravariant=True)
class IRelayCommand_1(typing.Generic[IRelayCommand_1_T], IRelayCommand_0, typing.Protocol):
    @abc.abstractmethod
    def CanExecute(self, parameter: IRelayCommand_1_T) -> bool: ...
    @abc.abstractmethod
    def Execute(self, parameter: IRelayCommand_1_T) -> None: ...


class RelayCommand_GenericClasses(abc.ABCMeta):
    Generic_RelayCommand_GenericClasses_RelayCommand_1_T = typing.TypeVar('Generic_RelayCommand_GenericClasses_RelayCommand_1_T')
    def __getitem__(self, types : typing.Type[Generic_RelayCommand_GenericClasses_RelayCommand_1_T]) -> typing.Type[RelayCommand_1[Generic_RelayCommand_GenericClasses_RelayCommand_1_T]]: ...

class RelayCommand(RelayCommand_0, metaclass =RelayCommand_GenericClasses): ...

class RelayCommand_0(IRelayCommand_0):
    @typing.overload
    def __init__(self, execute: Action) -> None: ...
    @typing.overload
    def __init__(self, execute: Action, canExecute: Func_1[bool]) -> None: ...
    def CanExecute(self, parameter: typing.Any) -> bool: ...
    def Execute(self, parameter: typing.Any) -> None: ...
    def NotifyCanExecuteChanged(self) -> None: ...


RelayCommand_1_T = typing.TypeVar('RelayCommand_1_T')
class RelayCommand_1(typing.Generic[RelayCommand_1_T], IRelayCommand_1[RelayCommand_1_T]):
    @typing.overload
    def __init__(self, execute: Action_1[RelayCommand_1_T]) -> None: ...
    @typing.overload
    def __init__(self, execute: Action_1[RelayCommand_1_T], canExecute: Predicate_1[RelayCommand_1_T]) -> None: ...
    def NotifyCanExecuteChanged(self) -> None: ...
    # Skipped CanExecute due to it being static, abstract and generic.

    CanExecute : CanExecute_MethodGroup[RelayCommand_1_T]
    CanExecute_MethodGroup_RelayCommand_1_T = typing.TypeVar('CanExecute_MethodGroup_RelayCommand_1_T')
    class CanExecute_MethodGroup(typing.Generic[CanExecute_MethodGroup_RelayCommand_1_T]):
        CanExecute_MethodGroup_RelayCommand_1_T = RelayCommand_1.CanExecute_MethodGroup_RelayCommand_1_T
        @typing.overload
        def __call__(self, parameter: CanExecute_MethodGroup_RelayCommand_1_T) -> bool:...
        @typing.overload
        def __call__(self, parameter: typing.Any) -> bool:...

    # Skipped Execute due to it being static, abstract and generic.

    Execute : Execute_MethodGroup[RelayCommand_1_T]
    Execute_MethodGroup_RelayCommand_1_T = typing.TypeVar('Execute_MethodGroup_RelayCommand_1_T')
    class Execute_MethodGroup(typing.Generic[Execute_MethodGroup_RelayCommand_1_T]):
        Execute_MethodGroup_RelayCommand_1_T = RelayCommand_1.Execute_MethodGroup_RelayCommand_1_T
        @typing.overload
        def __call__(self, parameter: Execute_MethodGroup_RelayCommand_1_T) -> None:...
        @typing.overload
        def __call__(self, parameter: typing.Any) -> None:...



class RelayCommandAttribute(Attribute):
    def __init__(self) -> None: ...
    @property
    def AllowConcurrentExecutions(self) -> bool: ...
    @AllowConcurrentExecutions.setter
    def AllowConcurrentExecutions(self, value: bool) -> bool: ...
    @property
    def CanExecute(self) -> str: ...
    @CanExecute.setter
    def CanExecute(self, value: str) -> str: ...
    @property
    def FlowExceptionsToTaskScheduler(self) -> bool: ...
    @FlowExceptionsToTaskScheduler.setter
    def FlowExceptionsToTaskScheduler(self, value: bool) -> bool: ...
    @property
    def IncludeCancelCommand(self) -> bool: ...
    @IncludeCancelCommand.setter
    def IncludeCancelCommand(self, value: bool) -> bool: ...
    @property
    def TypeId(self) -> typing.Any: ...

