import typing, clr, abc
from System.Collections.Generic import IEnumerable_1, IEnumerator_1, IList_1, IDictionary_2, KeyValuePair_2, IEqualityComparer_1
from System import Array_1, IEquatable_1, StringComparison, TimeSpan, ICloneable, Decimal, DateTime, DateTimeOffset, Guid, Uri, IConvertible, IComparable_1, IComparable, IFormattable, IFormatProvider
from Newtonsoft.Json import JsonWriter, JsonConverter, JsonSerializer, JsonReader, IJsonLineInfo, Formatting, DateParseHandling, DateTimeZoneHandling, FloatParseHandling, JsonToken, DateFormatHandling, FloatFormatHandling, StringEscapeHandling, WriteState
from System.Threading.Tasks import Task, Task_1
from System.Threading import CancellationToken
from System.ComponentModel import IBindingList, ITypedList, INotifyPropertyChanging, ICustomTypeDescriptor, INotifyPropertyChanged, PropertyDescriptor, AttributeCollection, TypeConverter, DesignerSerializationVisibility
from System.Collections.Specialized import INotifyCollectionChanged
from System.Dynamic import IDynamicMetaObjectProvider
from System.Globalization import CultureInfo

class CommentHandling(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Ignore : CommentHandling # 0
    Load : CommentHandling # 1


class DuplicatePropertyNameHandling(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Replace : DuplicatePropertyNameHandling # 0
    Ignore : DuplicatePropertyNameHandling # 1
    Error : DuplicatePropertyNameHandling # 2


class Extensions(abc.ABC):
    @staticmethod
    def Properties(source: IEnumerable_1[JObject]) -> IJEnumerable_1[JProperty]: ...
    # Skipped Ancestors due to it being static, abstract and generic.

    Ancestors : Ancestors_MethodGroup
    class Ancestors_MethodGroup:
        def __getitem__(self, t:typing.Type[Ancestors_1_T1]) -> Ancestors_1[Ancestors_1_T1]: ...

        Ancestors_1_T1 = typing.TypeVar('Ancestors_1_T1')
        class Ancestors_1(typing.Generic[Ancestors_1_T1]):
            Ancestors_1_T = Extensions.Ancestors_MethodGroup.Ancestors_1_T1
            def __call__(self, source: IEnumerable_1[Ancestors_1_T]) -> IJEnumerable_1[JToken]:...


    # Skipped AncestorsAndSelf due to it being static, abstract and generic.

    AncestorsAndSelf : AncestorsAndSelf_MethodGroup
    class AncestorsAndSelf_MethodGroup:
        def __getitem__(self, t:typing.Type[AncestorsAndSelf_1_T1]) -> AncestorsAndSelf_1[AncestorsAndSelf_1_T1]: ...

        AncestorsAndSelf_1_T1 = typing.TypeVar('AncestorsAndSelf_1_T1')
        class AncestorsAndSelf_1(typing.Generic[AncestorsAndSelf_1_T1]):
            AncestorsAndSelf_1_T = Extensions.AncestorsAndSelf_MethodGroup.AncestorsAndSelf_1_T1
            def __call__(self, source: IEnumerable_1[AncestorsAndSelf_1_T]) -> IJEnumerable_1[JToken]:...


    # Skipped AsJEnumerable due to it being static, abstract and generic.

    AsJEnumerable : AsJEnumerable_MethodGroup
    class AsJEnumerable_MethodGroup:
        def __getitem__(self, t:typing.Type[AsJEnumerable_1_T1]) -> AsJEnumerable_1[AsJEnumerable_1_T1]: ...

        AsJEnumerable_1_T1 = typing.TypeVar('AsJEnumerable_1_T1')
        class AsJEnumerable_1(typing.Generic[AsJEnumerable_1_T1]):
            AsJEnumerable_1_T = Extensions.AsJEnumerable_MethodGroup.AsJEnumerable_1_T1
            def __call__(self, source: IEnumerable_1[AsJEnumerable_1_T]) -> IJEnumerable_1[AsJEnumerable_1_T]:...

        def __call__(self, source: IEnumerable_1[JToken]) -> IJEnumerable_1[JToken]:...

    # Skipped Children due to it being static, abstract and generic.

    Children : Children_MethodGroup
    class Children_MethodGroup:
        @typing.overload
        def __getitem__(self, t:typing.Type[Children_1_T1]) -> Children_1[Children_1_T1]: ...

        Children_1_T1 = typing.TypeVar('Children_1_T1')
        class Children_1(typing.Generic[Children_1_T1]):
            Children_1_T = Extensions.Children_MethodGroup.Children_1_T1
            def __call__(self, source: IEnumerable_1[Children_1_T]) -> IJEnumerable_1[JToken]:...

        @typing.overload
        def __getitem__(self, t:typing.Tuple[typing.Type[Children_2_T1], typing.Type[Children_2_T2]]) -> Children_2[Children_2_T1, Children_2_T2]: ...

        Children_2_T1 = typing.TypeVar('Children_2_T1')
        Children_2_T2 = typing.TypeVar('Children_2_T2')
        class Children_2(typing.Generic[Children_2_T1, Children_2_T2]):
            Children_2_T = Extensions.Children_MethodGroup.Children_2_T1
            Children_2_U = Extensions.Children_MethodGroup.Children_2_T2
            def __call__(self, source: IEnumerable_1[Children_2_T]) -> IEnumerable_1[Children_2_U]:...


    # Skipped Descendants due to it being static, abstract and generic.

    Descendants : Descendants_MethodGroup
    class Descendants_MethodGroup:
        def __getitem__(self, t:typing.Type[Descendants_1_T1]) -> Descendants_1[Descendants_1_T1]: ...

        Descendants_1_T1 = typing.TypeVar('Descendants_1_T1')
        class Descendants_1(typing.Generic[Descendants_1_T1]):
            Descendants_1_T = Extensions.Descendants_MethodGroup.Descendants_1_T1
            def __call__(self, source: IEnumerable_1[Descendants_1_T]) -> IJEnumerable_1[JToken]:...


    # Skipped DescendantsAndSelf due to it being static, abstract and generic.

    DescendantsAndSelf : DescendantsAndSelf_MethodGroup
    class DescendantsAndSelf_MethodGroup:
        def __getitem__(self, t:typing.Type[DescendantsAndSelf_1_T1]) -> DescendantsAndSelf_1[DescendantsAndSelf_1_T1]: ...

        DescendantsAndSelf_1_T1 = typing.TypeVar('DescendantsAndSelf_1_T1')
        class DescendantsAndSelf_1(typing.Generic[DescendantsAndSelf_1_T1]):
            DescendantsAndSelf_1_T = Extensions.DescendantsAndSelf_MethodGroup.DescendantsAndSelf_1_T1
            def __call__(self, source: IEnumerable_1[DescendantsAndSelf_1_T]) -> IJEnumerable_1[JToken]:...


    # Skipped Value due to it being static, abstract and generic.

    Value : Value_MethodGroup
    class Value_MethodGroup:
        @typing.overload
        def __getitem__(self, t:typing.Tuple[typing.Type[Value_2_T1], typing.Type[Value_2_T2]]) -> Value_2[Value_2_T1, Value_2_T2]: ...

        Value_2_T1 = typing.TypeVar('Value_2_T1')
        Value_2_T2 = typing.TypeVar('Value_2_T2')
        class Value_2(typing.Generic[Value_2_T1, Value_2_T2]):
            Value_2_T = Extensions.Value_MethodGroup.Value_2_T1
            Value_2_U = Extensions.Value_MethodGroup.Value_2_T2
            def __call__(self, value: IEnumerable_1[Value_2_T]) -> Value_2_U:...

        @typing.overload
        def __getitem__(self, t:typing.Type[Value_1_T1]) -> Value_1[Value_1_T1]: ...

        Value_1_T1 = typing.TypeVar('Value_1_T1')
        class Value_1(typing.Generic[Value_1_T1]):
            Value_1_U = Extensions.Value_MethodGroup.Value_1_T1
            def __call__(self, value: IEnumerable_1[JToken]) -> Value_1_U:...


    # Skipped Values due to it being static, abstract and generic.

    Values : Values_MethodGroup
    class Values_MethodGroup:
        def __getitem__(self, t:typing.Type[Values_1_T1]) -> Values_1[Values_1_T1]: ...

        Values_1_T1 = typing.TypeVar('Values_1_T1')
        class Values_1(typing.Generic[Values_1_T1]):
            Values_1_U = Extensions.Values_MethodGroup.Values_1_T1
            @typing.overload
            def __call__(self, source: IEnumerable_1[JToken]) -> IEnumerable_1[Values_1_U]:...
            @typing.overload
            def __call__(self, source: IEnumerable_1[JToken], key: typing.Any) -> IEnumerable_1[Values_1_U]:...

        @typing.overload
        def __call__(self, source: IEnumerable_1[JToken]) -> IJEnumerable_1[JToken]:...
        @typing.overload
        def __call__(self, source: IEnumerable_1[JToken], key: typing.Any) -> IJEnumerable_1[JToken]:...



class IJEnumerable_GenericClasses(abc.ABCMeta):
    Generic_IJEnumerable_GenericClasses_IJEnumerable_1_T = typing.TypeVar('Generic_IJEnumerable_GenericClasses_IJEnumerable_1_T')
    def __getitem__(self, types : typing.Type[Generic_IJEnumerable_GenericClasses_IJEnumerable_1_T]) -> typing.Type[IJEnumerable_1[Generic_IJEnumerable_GenericClasses_IJEnumerable_1_T]]: ...

IJEnumerable : IJEnumerable_GenericClasses

IJEnumerable_1_T = typing.TypeVar('IJEnumerable_1_T', covariant=True)
class IJEnumerable_1(typing.Generic[IJEnumerable_1_T], IEnumerable_1[IJEnumerable_1_T], typing.Protocol):
    @property
    def Item(self) -> IJEnumerable_1[JToken]: ...


class JArray(JContainer):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, content: Array_1[typing.Any]) -> None: ...
    @typing.overload
    def __init__(self, content: typing.Any) -> None: ...
    @typing.overload
    def __init__(self, other: JArray) -> None: ...
    @property
    def Count(self) -> int: ...
    @property
    def First(self) -> JToken: ...
    @property
    def HasValues(self) -> bool: ...
    @property
    def IsReadOnly(self) -> bool: ...
    @property
    def Item(self) -> JToken: ...
    @Item.setter
    def Item(self, value: JToken) -> JToken: ...
    @property
    def Item(self) -> JToken: ...
    @Item.setter
    def Item(self, value: JToken) -> JToken: ...
    @property
    def Last(self) -> JToken: ...
    @property
    def Next(self) -> JToken: ...
    @Next.setter
    def Next(self, value: JToken) -> JToken: ...
    @property
    def Parent(self) -> JContainer: ...
    @Parent.setter
    def Parent(self, value: JContainer) -> JContainer: ...
    @property
    def Path(self) -> str: ...
    @property
    def Previous(self) -> JToken: ...
    @Previous.setter
    def Previous(self, value: JToken) -> JToken: ...
    @property
    def Root(self) -> JToken: ...
    @property
    def Type(self) -> JTokenType: ...
    def Add(self, item: JToken) -> None: ...
    def Clear(self) -> None: ...
    def Contains(self, item: JToken) -> bool: ...
    def CopyTo(self, array: Array_1[JToken], arrayIndex: int) -> None: ...
    def GetEnumerator(self) -> IEnumerator_1[JToken]: ...
    def IndexOf(self, item: JToken) -> int: ...
    def Insert(self, index: int, item: JToken) -> None: ...
    def Remove(self, item: JToken) -> bool: ...
    def RemoveAt(self, index: int) -> None: ...
    def WriteTo(self, writer: JsonWriter, converters: Array_1[JsonConverter]) -> None: ...
    def WriteToAsync(self, writer: JsonWriter, cancellationToken: CancellationToken, converters: Array_1[JsonConverter]) -> Task: ...
    # Skipped FromObject due to it being static, abstract and generic.

    FromObject : FromObject_MethodGroup
    class FromObject_MethodGroup:
        @typing.overload
        def __call__(self, o: typing.Any) -> JArray:...
        @typing.overload
        def __call__(self, o: typing.Any, jsonSerializer: JsonSerializer) -> JArray:...

    # Skipped Load due to it being static, abstract and generic.

    Load : Load_MethodGroup
    class Load_MethodGroup:
        @typing.overload
        def __call__(self, reader: JsonReader) -> JArray:...
        @typing.overload
        def __call__(self, reader: JsonReader, settings: JsonLoadSettings) -> JArray:...

    # Skipped LoadAsync due to it being static, abstract and generic.

    LoadAsync : LoadAsync_MethodGroup
    class LoadAsync_MethodGroup:
        @typing.overload
        def __call__(self, reader: JsonReader, cancellationToken: CancellationToken = ...) -> Task_1[JArray]:...
        @typing.overload
        def __call__(self, reader: JsonReader, settings: JsonLoadSettings, cancellationToken: CancellationToken = ...) -> Task_1[JArray]:...

    # Skipped Parse due to it being static, abstract and generic.

    Parse : Parse_MethodGroup
    class Parse_MethodGroup:
        @typing.overload
        def __call__(self, json: str) -> JArray:...
        @typing.overload
        def __call__(self, json: str, settings: JsonLoadSettings) -> JArray:...



class JConstructor(JContainer):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, name: str) -> None: ...
    @typing.overload
    def __init__(self, name: str, content: Array_1[typing.Any]) -> None: ...
    @typing.overload
    def __init__(self, name: str, content: typing.Any) -> None: ...
    @typing.overload
    def __init__(self, other: JConstructor) -> None: ...
    @property
    def Count(self) -> int: ...
    @property
    def First(self) -> JToken: ...
    @property
    def HasValues(self) -> bool: ...
    @property
    def Item(self) -> JToken: ...
    @Item.setter
    def Item(self, value: JToken) -> JToken: ...
    @property
    def Last(self) -> JToken: ...
    @property
    def Name(self) -> str: ...
    @Name.setter
    def Name(self, value: str) -> str: ...
    @property
    def Next(self) -> JToken: ...
    @Next.setter
    def Next(self, value: JToken) -> JToken: ...
    @property
    def Parent(self) -> JContainer: ...
    @Parent.setter
    def Parent(self, value: JContainer) -> JContainer: ...
    @property
    def Path(self) -> str: ...
    @property
    def Previous(self) -> JToken: ...
    @Previous.setter
    def Previous(self, value: JToken) -> JToken: ...
    @property
    def Root(self) -> JToken: ...
    @property
    def Type(self) -> JTokenType: ...
    def WriteTo(self, writer: JsonWriter, converters: Array_1[JsonConverter]) -> None: ...
    def WriteToAsync(self, writer: JsonWriter, cancellationToken: CancellationToken, converters: Array_1[JsonConverter]) -> Task: ...
    # Skipped Load due to it being static, abstract and generic.

    Load : Load_MethodGroup
    class Load_MethodGroup:
        @typing.overload
        def __call__(self, reader: JsonReader) -> JConstructor:...
        @typing.overload
        def __call__(self, reader: JsonReader, settings: JsonLoadSettings) -> JConstructor:...

    # Skipped LoadAsync due to it being static, abstract and generic.

    LoadAsync : LoadAsync_MethodGroup
    class LoadAsync_MethodGroup:
        @typing.overload
        def __call__(self, reader: JsonReader, cancellationToken: CancellationToken = ...) -> Task_1[JConstructor]:...
        @typing.overload
        def __call__(self, reader: JsonReader, settings: JsonLoadSettings, cancellationToken: CancellationToken = ...) -> Task_1[JConstructor]:...



class JContainer(JToken, IBindingList, IList_1[JToken], INotifyCollectionChanged, ITypedList):
    @property
    def Count(self) -> int: ...
    @property
    def First(self) -> JToken: ...
    @property
    def HasValues(self) -> bool: ...
    @property
    def Item(self) -> JToken: ...
    @Item.setter
    def Item(self, value: JToken) -> JToken: ...
    @property
    def Last(self) -> JToken: ...
    @property
    def Next(self) -> JToken: ...
    @Next.setter
    def Next(self, value: JToken) -> JToken: ...
    @property
    def Parent(self) -> JContainer: ...
    @Parent.setter
    def Parent(self, value: JContainer) -> JContainer: ...
    @property
    def Path(self) -> str: ...
    @property
    def Previous(self) -> JToken: ...
    @Previous.setter
    def Previous(self, value: JToken) -> JToken: ...
    @property
    def Root(self) -> JToken: ...
    @property
    def Type(self) -> JTokenType: ...
    def Add(self, content: typing.Any) -> None: ...
    def AddFirst(self, content: typing.Any) -> None: ...
    def Children(self) -> JEnumerable_1[JToken]: ...
    def CreateWriter(self) -> JsonWriter: ...
    def Descendants(self) -> IEnumerable_1[JToken]: ...
    def DescendantsAndSelf(self) -> IEnumerable_1[JToken]: ...
    def RemoveAll(self) -> None: ...
    def ReplaceAll(self, content: typing.Any) -> None: ...
    # Skipped Merge due to it being static, abstract and generic.

    Merge : Merge_MethodGroup
    class Merge_MethodGroup:
        @typing.overload
        def __call__(self, content: typing.Any) -> None:...
        @typing.overload
        def __call__(self, content: typing.Any, settings: JsonMergeSettings) -> None:...

    # Skipped Values due to it being static, abstract and generic.

    Values : Values_MethodGroup
    class Values_MethodGroup:
        def __getitem__(self, t:typing.Type[Values_1_T1]) -> Values_1[Values_1_T1]: ...

        Values_1_T1 = typing.TypeVar('Values_1_T1')
        class Values_1(typing.Generic[Values_1_T1]):
            Values_1_T = JContainer.Values_MethodGroup.Values_1_T1
            def __call__(self) -> IEnumerable_1[Values_1_T]:...




class JEnumerable_GenericClasses(abc.ABCMeta):
    Generic_JEnumerable_GenericClasses_JEnumerable_1_T = typing.TypeVar('Generic_JEnumerable_GenericClasses_JEnumerable_1_T')
    def __getitem__(self, types : typing.Type[Generic_JEnumerable_GenericClasses_JEnumerable_1_T]) -> typing.Type[JEnumerable_1[Generic_JEnumerable_GenericClasses_JEnumerable_1_T]]: ...

JEnumerable : JEnumerable_GenericClasses

JEnumerable_1_T = typing.TypeVar('JEnumerable_1_T')
class JEnumerable_1(typing.Generic[JEnumerable_1_T], IJEnumerable_1[JEnumerable_1_T], IEquatable_1[JEnumerable_1[JEnumerable_1_T]]):
    def __init__(self, enumerable: IEnumerable_1[JEnumerable_1_T]) -> None: ...
    Empty : JEnumerable_1[JEnumerable_1_T]
    @property
    def Item(self) -> IJEnumerable_1[JToken]: ...
    def GetEnumerator(self) -> IEnumerator_1[JEnumerable_1_T]: ...
    def GetHashCode(self) -> int: ...
    # Skipped Equals due to it being static, abstract and generic.

    Equals : Equals_MethodGroup[JEnumerable_1_T]
    Equals_MethodGroup_JEnumerable_1_T = typing.TypeVar('Equals_MethodGroup_JEnumerable_1_T')
    class Equals_MethodGroup(typing.Generic[Equals_MethodGroup_JEnumerable_1_T]):
        Equals_MethodGroup_JEnumerable_1_T = JEnumerable_1.Equals_MethodGroup_JEnumerable_1_T
        @typing.overload
        def __call__(self, other: JEnumerable_1[Equals_MethodGroup_JEnumerable_1_T]) -> bool:...
        @typing.overload
        def __call__(self, obj: typing.Any) -> bool:...



class JObject(JContainer, IDictionary_2[str, JToken], INotifyPropertyChanging, ICustomTypeDescriptor, INotifyPropertyChanged):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, content: Array_1[typing.Any]) -> None: ...
    @typing.overload
    def __init__(self, content: typing.Any) -> None: ...
    @typing.overload
    def __init__(self, other: JObject) -> None: ...
    @property
    def Count(self) -> int: ...
    @property
    def First(self) -> JToken: ...
    @property
    def HasValues(self) -> bool: ...
    @property
    def Item(self) -> JToken: ...
    @Item.setter
    def Item(self, value: JToken) -> JToken: ...
    @property
    def Item(self) -> JToken: ...
    @Item.setter
    def Item(self, value: JToken) -> JToken: ...
    @property
    def Last(self) -> JToken: ...
    @property
    def Next(self) -> JToken: ...
    @Next.setter
    def Next(self, value: JToken) -> JToken: ...
    @property
    def Parent(self) -> JContainer: ...
    @Parent.setter
    def Parent(self, value: JContainer) -> JContainer: ...
    @property
    def Path(self) -> str: ...
    @property
    def Previous(self) -> JToken: ...
    @Previous.setter
    def Previous(self, value: JToken) -> JToken: ...
    @property
    def Root(self) -> JToken: ...
    @property
    def Type(self) -> JTokenType: ...
    def Add(self, propertyName: str, value: JToken) -> None: ...
    def ContainsKey(self, propertyName: str) -> bool: ...
    def GetEnumerator(self) -> IEnumerator_1[KeyValuePair_2[str, JToken]]: ...
    def Properties(self) -> IEnumerable_1[JProperty]: ...
    def PropertyValues(self) -> JEnumerable_1[JToken]: ...
    def Remove(self, propertyName: str) -> bool: ...
    def WriteTo(self, writer: JsonWriter, converters: Array_1[JsonConverter]) -> None: ...
    def WriteToAsync(self, writer: JsonWriter, cancellationToken: CancellationToken, converters: Array_1[JsonConverter]) -> Task: ...
    # Skipped FromObject due to it being static, abstract and generic.

    FromObject : FromObject_MethodGroup
    class FromObject_MethodGroup:
        @typing.overload
        def __call__(self, o: typing.Any) -> JObject:...
        @typing.overload
        def __call__(self, o: typing.Any, jsonSerializer: JsonSerializer) -> JObject:...

    # Skipped GetValue due to it being static, abstract and generic.

    GetValue : GetValue_MethodGroup
    class GetValue_MethodGroup:
        @typing.overload
        def __call__(self, propertyName: str) -> JToken:...
        @typing.overload
        def __call__(self, propertyName: str, comparison: StringComparison) -> JToken:...

    # Skipped Load due to it being static, abstract and generic.

    Load : Load_MethodGroup
    class Load_MethodGroup:
        @typing.overload
        def __call__(self, reader: JsonReader) -> JObject:...
        @typing.overload
        def __call__(self, reader: JsonReader, settings: JsonLoadSettings) -> JObject:...

    # Skipped LoadAsync due to it being static, abstract and generic.

    LoadAsync : LoadAsync_MethodGroup
    class LoadAsync_MethodGroup:
        @typing.overload
        def __call__(self, reader: JsonReader, cancellationToken: CancellationToken = ...) -> Task_1[JObject]:...
        @typing.overload
        def __call__(self, reader: JsonReader, settings: JsonLoadSettings, cancellationToken: CancellationToken = ...) -> Task_1[JObject]:...

    # Skipped Parse due to it being static, abstract and generic.

    Parse : Parse_MethodGroup
    class Parse_MethodGroup:
        @typing.overload
        def __call__(self, json: str) -> JObject:...
        @typing.overload
        def __call__(self, json: str, settings: JsonLoadSettings) -> JObject:...

    # Skipped Property due to it being static, abstract and generic.

    Property : Property_MethodGroup
    class Property_MethodGroup:
        @typing.overload
        def __call__(self, name: str) -> JProperty:...
        @typing.overload
        def __call__(self, name: str, comparison: StringComparison) -> JProperty:...

    # Skipped TryGetValue due to it being static, abstract and generic.

    TryGetValue : TryGetValue_MethodGroup
    class TryGetValue_MethodGroup:
        @typing.overload
        def __call__(self, propertyName: str, value: clr.Reference[JToken]) -> bool:...
        @typing.overload
        def __call__(self, propertyName: str, comparison: StringComparison, value: clr.Reference[JToken]) -> bool:...



class JProperty(JContainer):
    @typing.overload
    def __init__(self, name: str, content: Array_1[typing.Any]) -> None: ...
    @typing.overload
    def __init__(self, name: str, content: typing.Any) -> None: ...
    @typing.overload
    def __init__(self, other: JProperty) -> None: ...
    @property
    def Count(self) -> int: ...
    @property
    def First(self) -> JToken: ...
    @property
    def HasValues(self) -> bool: ...
    @property
    def Item(self) -> JToken: ...
    @Item.setter
    def Item(self, value: JToken) -> JToken: ...
    @property
    def Last(self) -> JToken: ...
    @property
    def Name(self) -> str: ...
    @property
    def Next(self) -> JToken: ...
    @Next.setter
    def Next(self, value: JToken) -> JToken: ...
    @property
    def Parent(self) -> JContainer: ...
    @Parent.setter
    def Parent(self, value: JContainer) -> JContainer: ...
    @property
    def Path(self) -> str: ...
    @property
    def Previous(self) -> JToken: ...
    @Previous.setter
    def Previous(self, value: JToken) -> JToken: ...
    @property
    def Root(self) -> JToken: ...
    @property
    def Type(self) -> JTokenType: ...
    @property
    def Value(self) -> JToken: ...
    @Value.setter
    def Value(self, value: JToken) -> JToken: ...
    def WriteTo(self, writer: JsonWriter, converters: Array_1[JsonConverter]) -> None: ...
    def WriteToAsync(self, writer: JsonWriter, cancellationToken: CancellationToken, converters: Array_1[JsonConverter]) -> Task: ...
    # Skipped Load due to it being static, abstract and generic.

    Load : Load_MethodGroup
    class Load_MethodGroup:
        @typing.overload
        def __call__(self, reader: JsonReader) -> JProperty:...
        @typing.overload
        def __call__(self, reader: JsonReader, settings: JsonLoadSettings) -> JProperty:...

    # Skipped LoadAsync due to it being static, abstract and generic.

    LoadAsync : LoadAsync_MethodGroup
    class LoadAsync_MethodGroup:
        @typing.overload
        def __call__(self, reader: JsonReader, cancellationToken: CancellationToken = ...) -> Task_1[JProperty]:...
        @typing.overload
        def __call__(self, reader: JsonReader, settings: JsonLoadSettings, cancellationToken: CancellationToken = ...) -> Task_1[JProperty]:...



class JPropertyDescriptor(PropertyDescriptor):
    def __init__(self, name: str) -> None: ...
    @property
    def Attributes(self) -> AttributeCollection: ...
    @property
    def Category(self) -> str: ...
    @property
    def ComponentType(self) -> typing.Type[typing.Any]: ...
    @property
    def Converter(self) -> TypeConverter: ...
    @property
    def Description(self) -> str: ...
    @property
    def DesignTimeOnly(self) -> bool: ...
    @property
    def DisplayName(self) -> str: ...
    @property
    def IsBrowsable(self) -> bool: ...
    @property
    def IsLocalizable(self) -> bool: ...
    @property
    def IsReadOnly(self) -> bool: ...
    @property
    def Name(self) -> str: ...
    @property
    def PropertyType(self) -> typing.Type[typing.Any]: ...
    @property
    def SerializationVisibility(self) -> DesignerSerializationVisibility: ...
    @property
    def SupportsChangeEvents(self) -> bool: ...
    def CanResetValue(self, component: typing.Any) -> bool: ...
    def GetValue(self, component: typing.Any) -> typing.Any: ...
    def ResetValue(self, component: typing.Any) -> None: ...
    def SetValue(self, component: typing.Any, value: typing.Any) -> None: ...
    def ShouldSerializeValue(self, component: typing.Any) -> bool: ...


class JRaw(JValue):
    @typing.overload
    def __init__(self, other: JRaw) -> None: ...
    @typing.overload
    def __init__(self, rawJson: typing.Any) -> None: ...
    @property
    def First(self) -> JToken: ...
    @property
    def HasValues(self) -> bool: ...
    @property
    def Item(self) -> JToken: ...
    @Item.setter
    def Item(self, value: JToken) -> JToken: ...
    @property
    def Last(self) -> JToken: ...
    @property
    def Next(self) -> JToken: ...
    @Next.setter
    def Next(self, value: JToken) -> JToken: ...
    @property
    def Parent(self) -> JContainer: ...
    @Parent.setter
    def Parent(self, value: JContainer) -> JContainer: ...
    @property
    def Path(self) -> str: ...
    @property
    def Previous(self) -> JToken: ...
    @Previous.setter
    def Previous(self, value: JToken) -> JToken: ...
    @property
    def Root(self) -> JToken: ...
    @property
    def Type(self) -> JTokenType: ...
    @property
    def Value(self) -> typing.Any: ...
    @Value.setter
    def Value(self, value: typing.Any) -> typing.Any: ...
    @staticmethod
    def Create(reader: JsonReader) -> JRaw: ...
    @staticmethod
    def CreateAsync(reader: JsonReader, cancellationToken: CancellationToken = ...) -> Task_1[JRaw]: ...


class JsonCloneSettings:
    def __init__(self) -> None: ...
    @property
    def CopyAnnotations(self) -> bool: ...
    @CopyAnnotations.setter
    def CopyAnnotations(self, value: bool) -> bool: ...


class JsonLoadSettings:
    def __init__(self) -> None: ...
    @property
    def CommentHandling(self) -> CommentHandling: ...
    @CommentHandling.setter
    def CommentHandling(self, value: CommentHandling) -> CommentHandling: ...
    @property
    def DuplicatePropertyNameHandling(self) -> DuplicatePropertyNameHandling: ...
    @DuplicatePropertyNameHandling.setter
    def DuplicatePropertyNameHandling(self, value: DuplicatePropertyNameHandling) -> DuplicatePropertyNameHandling: ...
    @property
    def LineInfoHandling(self) -> LineInfoHandling: ...
    @LineInfoHandling.setter
    def LineInfoHandling(self, value: LineInfoHandling) -> LineInfoHandling: ...


class JsonMergeSettings:
    def __init__(self) -> None: ...
    @property
    def MergeArrayHandling(self) -> MergeArrayHandling: ...
    @MergeArrayHandling.setter
    def MergeArrayHandling(self, value: MergeArrayHandling) -> MergeArrayHandling: ...
    @property
    def MergeNullValueHandling(self) -> MergeNullValueHandling: ...
    @MergeNullValueHandling.setter
    def MergeNullValueHandling(self, value: MergeNullValueHandling) -> MergeNullValueHandling: ...
    @property
    def PropertyNameComparison(self) -> StringComparison: ...
    @PropertyNameComparison.setter
    def PropertyNameComparison(self, value: StringComparison) -> StringComparison: ...


class JsonSelectSettings:
    def __init__(self) -> None: ...
    @property
    def ErrorWhenNoMatch(self) -> bool: ...
    @ErrorWhenNoMatch.setter
    def ErrorWhenNoMatch(self, value: bool) -> bool: ...
    @property
    def RegexMatchTimeout(self) -> typing.Optional[TimeSpan]: ...
    @RegexMatchTimeout.setter
    def RegexMatchTimeout(self, value: typing.Optional[TimeSpan]) -> typing.Optional[TimeSpan]: ...


class JToken(IJEnumerable_1[JToken], IDynamicMetaObjectProvider, ICloneable, IJsonLineInfo, abc.ABC):
    @classmethod
    @property
    def EqualityComparer(cls) -> JTokenEqualityComparer: ...
    @property
    def First(self) -> JToken: ...
    @property
    def HasValues(self) -> bool: ...
    @property
    def Item(self) -> JToken: ...
    @Item.setter
    def Item(self, value: JToken) -> JToken: ...
    @property
    def Last(self) -> JToken: ...
    @property
    def Next(self) -> JToken: ...
    @Next.setter
    def Next(self, value: JToken) -> JToken: ...
    @property
    def Parent(self) -> JContainer: ...
    @Parent.setter
    def Parent(self, value: JContainer) -> JContainer: ...
    @property
    def Path(self) -> str: ...
    @property
    def Previous(self) -> JToken: ...
    @Previous.setter
    def Previous(self, value: JToken) -> JToken: ...
    @property
    def Root(self) -> JToken: ...
    @property
    def Type(self) -> JTokenType: ...
    def AddAfterSelf(self, content: typing.Any) -> None: ...
    def AddAnnotation(self, annotation: typing.Any) -> None: ...
    def AddBeforeSelf(self, content: typing.Any) -> None: ...
    def AfterSelf(self) -> IEnumerable_1[JToken]: ...
    def Ancestors(self) -> IEnumerable_1[JToken]: ...
    def AncestorsAndSelf(self) -> IEnumerable_1[JToken]: ...
    def BeforeSelf(self) -> IEnumerable_1[JToken]: ...
    def CreateReader(self) -> JsonReader: ...
    @staticmethod
    def DeepEquals(t1: JToken, t2: JToken) -> bool: ...
    # Operator not supported op_Explicit(value: JToken)
    # Operator not supported op_Explicit(value: JToken)
    # Operator not supported op_Explicit(value: JToken)
    # Operator not supported op_Explicit(value: JToken)
    # Operator not supported op_Explicit(value: JToken)
    # Operator not supported op_Explicit(value: JToken)
    # Operator not supported op_Explicit(value: JToken)
    # Operator not supported op_Explicit(value: JToken)
    # Operator not supported op_Explicit(value: JToken)
    # Operator not supported op_Explicit(value: JToken)
    # Operator not supported op_Explicit(value: JToken)
    # Operator not supported op_Explicit(value: JToken)
    # Operator not supported op_Explicit(value: JToken)
    # Operator not supported op_Explicit(value: JToken)
    # Operator not supported op_Explicit(value: JToken)
    # Operator not supported op_Explicit(value: JToken)
    # Operator not supported op_Explicit(value: JToken)
    # Operator not supported op_Explicit(value: JToken)
    # Operator not supported op_Explicit(value: JToken)
    # Operator not supported op_Explicit(value: JToken)
    # Operator not supported op_Explicit(value: JToken)
    # Operator not supported op_Explicit(value: JToken)
    # Operator not supported op_Explicit(value: JToken)
    # Operator not supported op_Explicit(value: JToken)
    # Operator not supported op_Explicit(value: JToken)
    # Operator not supported op_Explicit(value: JToken)
    # Operator not supported op_Explicit(value: JToken)
    # Operator not supported op_Explicit(value: JToken)
    # Operator not supported op_Explicit(value: JToken)
    # Operator not supported op_Explicit(value: JToken)
    # Operator not supported op_Explicit(value: JToken)
    # Operator not supported op_Explicit(value: JToken)
    # Operator not supported op_Explicit(value: JToken)
    # Operator not supported op_Explicit(value: JToken)
    # Operator not supported op_Explicit(value: JToken)
    # Operator not supported op_Explicit(value: JToken)
    # Operator not supported op_Explicit(value: JToken)
    # Operator not supported op_Implicit(value: Double)
    # Operator not supported op_Implicit(value: Single)
    # Operator not supported op_Implicit(value: Byte)
    # Operator not supported op_Implicit(value: SByte)
    # Operator not supported op_Implicit(value: Int64)
    # Operator not supported op_Implicit(value: Int16)
    # Operator not supported op_Implicit(value: UInt16)
    # Operator not supported op_Implicit(value: Int32)
    # Operator not supported op_Implicit(value: UInt32)
    # Operator not supported op_Implicit(value: UInt64)
    # Operator not supported op_Implicit(value: Decimal)
    # Operator not supported op_Implicit(value: Byte[])
    # Operator not supported op_Implicit(value: Nullable`1)
    # Operator not supported op_Implicit(value: Nullable`1)
    # Operator not supported op_Implicit(value: Nullable`1)
    # Operator not supported op_Implicit(value: Nullable`1)
    # Operator not supported op_Implicit(value: Nullable`1)
    # Operator not supported op_Implicit(value: Nullable`1)
    # Operator not supported op_Implicit(value: Nullable`1)
    # Operator not supported op_Implicit(value: Nullable`1)
    # Operator not supported op_Implicit(value: Nullable`1)
    # Operator not supported op_Implicit(value: Nullable`1)
    # Operator not supported op_Implicit(value: Nullable`1)
    # Operator not supported op_Implicit(value: Nullable`1)
    # Operator not supported op_Implicit(value: Nullable`1)
    # Operator not supported op_Implicit(value: Nullable`1)
    # Operator not supported op_Implicit(value: Nullable`1)
    # Operator not supported op_Implicit(value: Nullable`1)
    # Operator not supported op_Implicit(value: Boolean)
    # Operator not supported op_Implicit(value: DateTimeOffset)
    # Operator not supported op_Implicit(value: DateTime)
    # Operator not supported op_Implicit(value: String)
    # Operator not supported op_Implicit(value: Uri)
    # Operator not supported op_Implicit(value: TimeSpan)
    # Operator not supported op_Implicit(value: Guid)
    def Remove(self) -> None: ...
    def Replace(self, value: JToken) -> None: ...
    @abc.abstractmethod
    def WriteTo(self, writer: JsonWriter, converters: Array_1[JsonConverter]) -> None: ...
    # Skipped Annotation due to it being static, abstract and generic.

    Annotation : Annotation_MethodGroup
    class Annotation_MethodGroup:
        def __getitem__(self, t:typing.Type[Annotation_1_T1]) -> Annotation_1[Annotation_1_T1]: ...

        Annotation_1_T1 = typing.TypeVar('Annotation_1_T1')
        class Annotation_1(typing.Generic[Annotation_1_T1]):
            Annotation_1_T = JToken.Annotation_MethodGroup.Annotation_1_T1
            def __call__(self) -> Annotation_1_T:...

        def __call__(self, type: typing.Type[typing.Any]) -> typing.Any:...

    # Skipped Annotations due to it being static, abstract and generic.

    Annotations : Annotations_MethodGroup
    class Annotations_MethodGroup:
        def __getitem__(self, t:typing.Type[Annotations_1_T1]) -> Annotations_1[Annotations_1_T1]: ...

        Annotations_1_T1 = typing.TypeVar('Annotations_1_T1')
        class Annotations_1(typing.Generic[Annotations_1_T1]):
            Annotations_1_T = JToken.Annotations_MethodGroup.Annotations_1_T1
            def __call__(self) -> IEnumerable_1[Annotations_1_T]:...

        def __call__(self, type: typing.Type[typing.Any]) -> IEnumerable_1[typing.Any]:...

    # Skipped Children due to it being static, abstract and generic.

    Children : Children_MethodGroup
    class Children_MethodGroup:
        def __getitem__(self, t:typing.Type[Children_1_T1]) -> Children_1[Children_1_T1]: ...

        Children_1_T1 = typing.TypeVar('Children_1_T1')
        class Children_1(typing.Generic[Children_1_T1]):
            Children_1_T = JToken.Children_MethodGroup.Children_1_T1
            def __call__(self) -> JEnumerable_1[Children_1_T]:...

        def __call__(self) -> JEnumerable_1[JToken]:...

    # Skipped DeepClone due to it being static, abstract and generic.

    DeepClone : DeepClone_MethodGroup
    class DeepClone_MethodGroup:
        @typing.overload
        def __call__(self) -> JToken:...
        @typing.overload
        def __call__(self, settings: JsonCloneSettings) -> JToken:...

    # Skipped FromObject due to it being static, abstract and generic.

    FromObject : FromObject_MethodGroup
    class FromObject_MethodGroup:
        @typing.overload
        def __call__(self, o: typing.Any) -> JToken:...
        @typing.overload
        def __call__(self, o: typing.Any, jsonSerializer: JsonSerializer) -> JToken:...

    # Skipped Load due to it being static, abstract and generic.

    Load : Load_MethodGroup
    class Load_MethodGroup:
        @typing.overload
        def __call__(self, reader: JsonReader) -> JToken:...
        @typing.overload
        def __call__(self, reader: JsonReader, settings: JsonLoadSettings) -> JToken:...

    # Skipped LoadAsync due to it being static, abstract and generic.

    LoadAsync : LoadAsync_MethodGroup
    class LoadAsync_MethodGroup:
        @typing.overload
        def __call__(self, reader: JsonReader, cancellationToken: CancellationToken = ...) -> Task_1[JToken]:...
        @typing.overload
        def __call__(self, reader: JsonReader, settings: JsonLoadSettings, cancellationToken: CancellationToken = ...) -> Task_1[JToken]:...

    # Skipped Parse due to it being static, abstract and generic.

    Parse : Parse_MethodGroup
    class Parse_MethodGroup:
        @typing.overload
        def __call__(self, json: str) -> JToken:...
        @typing.overload
        def __call__(self, json: str, settings: JsonLoadSettings) -> JToken:...

    # Skipped ReadFrom due to it being static, abstract and generic.

    ReadFrom : ReadFrom_MethodGroup
    class ReadFrom_MethodGroup:
        @typing.overload
        def __call__(self, reader: JsonReader) -> JToken:...
        @typing.overload
        def __call__(self, reader: JsonReader, settings: JsonLoadSettings) -> JToken:...

    # Skipped ReadFromAsync due to it being static, abstract and generic.

    ReadFromAsync : ReadFromAsync_MethodGroup
    class ReadFromAsync_MethodGroup:
        @typing.overload
        def __call__(self, reader: JsonReader, cancellationToken: CancellationToken = ...) -> Task_1[JToken]:...
        @typing.overload
        def __call__(self, reader: JsonReader, settings: JsonLoadSettings, cancellationToken: CancellationToken = ...) -> Task_1[JToken]:...

    # Skipped RemoveAnnotations due to it being static, abstract and generic.

    RemoveAnnotations : RemoveAnnotations_MethodGroup
    class RemoveAnnotations_MethodGroup:
        def __getitem__(self, t:typing.Type[RemoveAnnotations_1_T1]) -> RemoveAnnotations_1[RemoveAnnotations_1_T1]: ...

        RemoveAnnotations_1_T1 = typing.TypeVar('RemoveAnnotations_1_T1')
        class RemoveAnnotations_1(typing.Generic[RemoveAnnotations_1_T1]):
            RemoveAnnotations_1_T = JToken.RemoveAnnotations_MethodGroup.RemoveAnnotations_1_T1
            def __call__(self) -> None:...

        def __call__(self, type: typing.Type[typing.Any]) -> None:...

    # Skipped SelectToken due to it being static, abstract and generic.

    SelectToken : SelectToken_MethodGroup
    class SelectToken_MethodGroup:
        @typing.overload
        def __call__(self, path: str) -> JToken:...
        @typing.overload
        def __call__(self, path: str, errorWhenNoMatch: bool) -> JToken:...
        @typing.overload
        def __call__(self, path: str, settings: JsonSelectSettings) -> JToken:...

    # Skipped SelectTokens due to it being static, abstract and generic.

    SelectTokens : SelectTokens_MethodGroup
    class SelectTokens_MethodGroup:
        @typing.overload
        def __call__(self, path: str) -> IEnumerable_1[JToken]:...
        @typing.overload
        def __call__(self, path: str, errorWhenNoMatch: bool) -> IEnumerable_1[JToken]:...
        @typing.overload
        def __call__(self, path: str, settings: JsonSelectSettings) -> IEnumerable_1[JToken]:...

    # Skipped ToObject due to it being static, abstract and generic.

    ToObject : ToObject_MethodGroup
    class ToObject_MethodGroup:
        def __getitem__(self, t:typing.Type[ToObject_1_T1]) -> ToObject_1[ToObject_1_T1]: ...

        ToObject_1_T1 = typing.TypeVar('ToObject_1_T1')
        class ToObject_1(typing.Generic[ToObject_1_T1]):
            ToObject_1_T = JToken.ToObject_MethodGroup.ToObject_1_T1
            @typing.overload
            def __call__(self) -> ToObject_1_T:...
            @typing.overload
            def __call__(self, jsonSerializer: JsonSerializer) -> ToObject_1_T:...

        @typing.overload
        def __call__(self, objectType: typing.Type[typing.Any]) -> typing.Any:...
        @typing.overload
        def __call__(self, objectType: typing.Type[typing.Any], jsonSerializer: JsonSerializer) -> typing.Any:...

    # Skipped ToString due to it being static, abstract and generic.

    ToString : ToString_MethodGroup
    class ToString_MethodGroup:
        @typing.overload
        def __call__(self) -> str:...
        @typing.overload
        def __call__(self, formatting: Formatting, converters: Array_1[JsonConverter]) -> str:...

    # Skipped Value due to it being static, abstract and generic.

    Value : Value_MethodGroup
    class Value_MethodGroup:
        def __getitem__(self, t:typing.Type[Value_1_T1]) -> Value_1[Value_1_T1]: ...

        Value_1_T1 = typing.TypeVar('Value_1_T1')
        class Value_1(typing.Generic[Value_1_T1]):
            Value_1_T = JToken.Value_MethodGroup.Value_1_T1
            def __call__(self, key: typing.Any) -> Value_1_T:...


    # Skipped Values due to it being static, abstract and generic.

    Values : Values_MethodGroup
    class Values_MethodGroup:
        def __getitem__(self, t:typing.Type[Values_1_T1]) -> Values_1[Values_1_T1]: ...

        Values_1_T1 = typing.TypeVar('Values_1_T1')
        class Values_1(typing.Generic[Values_1_T1]):
            Values_1_T = JToken.Values_MethodGroup.Values_1_T1
            def __call__(self) -> IEnumerable_1[Values_1_T]:...


    # Skipped WriteToAsync due to it being static, abstract and generic.

    WriteToAsync : WriteToAsync_MethodGroup
    class WriteToAsync_MethodGroup:
        @typing.overload
        def __call__(self, writer: JsonWriter, converters: Array_1[JsonConverter]) -> Task:...
        @typing.overload
        def __call__(self, writer: JsonWriter, cancellationToken: CancellationToken, converters: Array_1[JsonConverter]) -> Task:...



class JTokenEqualityComparer(IEqualityComparer_1[JToken]):
    def __init__(self) -> None: ...
    def Equals(self, x: JToken, y: JToken) -> bool: ...
    def GetHashCode(self, obj: JToken) -> int: ...


class JTokenReader(JsonReader, IJsonLineInfo):
    @typing.overload
    def __init__(self, token: JToken) -> None: ...
    @typing.overload
    def __init__(self, token: JToken, initialPath: str) -> None: ...
    @property
    def CloseInput(self) -> bool: ...
    @CloseInput.setter
    def CloseInput(self, value: bool) -> bool: ...
    @property
    def Culture(self) -> CultureInfo: ...
    @Culture.setter
    def Culture(self, value: CultureInfo) -> CultureInfo: ...
    @property
    def CurrentToken(self) -> JToken: ...
    @property
    def DateFormatString(self) -> str: ...
    @DateFormatString.setter
    def DateFormatString(self, value: str) -> str: ...
    @property
    def DateParseHandling(self) -> DateParseHandling: ...
    @DateParseHandling.setter
    def DateParseHandling(self, value: DateParseHandling) -> DateParseHandling: ...
    @property
    def DateTimeZoneHandling(self) -> DateTimeZoneHandling: ...
    @DateTimeZoneHandling.setter
    def DateTimeZoneHandling(self, value: DateTimeZoneHandling) -> DateTimeZoneHandling: ...
    @property
    def Depth(self) -> int: ...
    @property
    def FloatParseHandling(self) -> FloatParseHandling: ...
    @FloatParseHandling.setter
    def FloatParseHandling(self, value: FloatParseHandling) -> FloatParseHandling: ...
    @property
    def MaxDepth(self) -> typing.Optional[int]: ...
    @MaxDepth.setter
    def MaxDepth(self, value: typing.Optional[int]) -> typing.Optional[int]: ...
    @property
    def Path(self) -> str: ...
    @property
    def QuoteChar(self) -> str: ...
    @QuoteChar.setter
    def QuoteChar(self, value: str) -> str: ...
    @property
    def SupportMultipleContent(self) -> bool: ...
    @SupportMultipleContent.setter
    def SupportMultipleContent(self, value: bool) -> bool: ...
    @property
    def TokenType(self) -> JsonToken: ...
    @property
    def Value(self) -> typing.Any: ...
    @property
    def ValueType(self) -> typing.Type[typing.Any]: ...
    def Read(self) -> bool: ...


class JTokenType(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    None_ : JTokenType # 0
    Object : JTokenType # 1
    Array : JTokenType # 2
    Constructor : JTokenType # 3
    Property : JTokenType # 4
    Comment : JTokenType # 5
    Integer : JTokenType # 6
    Float : JTokenType # 7
    String : JTokenType # 8
    Boolean : JTokenType # 9
    Null : JTokenType # 10
    Undefined : JTokenType # 11
    Date : JTokenType # 12
    Raw : JTokenType # 13
    Bytes : JTokenType # 14
    Guid : JTokenType # 15
    Uri : JTokenType # 16
    TimeSpan : JTokenType # 17


class JTokenWriter(JsonWriter):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, container: JContainer) -> None: ...
    @property
    def AutoCompleteOnClose(self) -> bool: ...
    @AutoCompleteOnClose.setter
    def AutoCompleteOnClose(self, value: bool) -> bool: ...
    @property
    def CloseOutput(self) -> bool: ...
    @CloseOutput.setter
    def CloseOutput(self, value: bool) -> bool: ...
    @property
    def Culture(self) -> CultureInfo: ...
    @Culture.setter
    def Culture(self, value: CultureInfo) -> CultureInfo: ...
    @property
    def CurrentToken(self) -> JToken: ...
    @property
    def DateFormatHandling(self) -> DateFormatHandling: ...
    @DateFormatHandling.setter
    def DateFormatHandling(self, value: DateFormatHandling) -> DateFormatHandling: ...
    @property
    def DateFormatString(self) -> str: ...
    @DateFormatString.setter
    def DateFormatString(self, value: str) -> str: ...
    @property
    def DateTimeZoneHandling(self) -> DateTimeZoneHandling: ...
    @DateTimeZoneHandling.setter
    def DateTimeZoneHandling(self, value: DateTimeZoneHandling) -> DateTimeZoneHandling: ...
    @property
    def FloatFormatHandling(self) -> FloatFormatHandling: ...
    @FloatFormatHandling.setter
    def FloatFormatHandling(self, value: FloatFormatHandling) -> FloatFormatHandling: ...
    @property
    def Formatting(self) -> Formatting: ...
    @Formatting.setter
    def Formatting(self, value: Formatting) -> Formatting: ...
    @property
    def Path(self) -> str: ...
    @property
    def StringEscapeHandling(self) -> StringEscapeHandling: ...
    @StringEscapeHandling.setter
    def StringEscapeHandling(self, value: StringEscapeHandling) -> StringEscapeHandling: ...
    @property
    def Token(self) -> JToken: ...
    @property
    def WriteState(self) -> WriteState: ...
    def Close(self) -> None: ...
    def Flush(self) -> None: ...
    def WriteComment(self, text: str) -> None: ...
    def WriteNull(self) -> None: ...
    def WritePropertyName(self, name: str) -> None: ...
    def WriteRaw(self, json: str) -> None: ...
    def WriteStartArray(self) -> None: ...
    def WriteStartConstructor(self, name: str) -> None: ...
    def WriteStartObject(self) -> None: ...
    def WriteUndefined(self) -> None: ...
    # Skipped WriteValue due to it being static, abstract and generic.

    WriteValue : WriteValue_MethodGroup
    class WriteValue_MethodGroup:
        @typing.overload
        def __call__(self, value: float) -> None:...
        # Method WriteValue(value : Double) was skipped since it collides with above method
        # Method WriteValue(value : Int32) was skipped since it collides with above method
        # Method WriteValue(value : UInt32) was skipped since it collides with above method
        # Method WriteValue(value : Int64) was skipped since it collides with above method
        # Method WriteValue(value : UInt64) was skipped since it collides with above method
        # Method WriteValue(value : Int16) was skipped since it collides with above method
        # Method WriteValue(value : UInt16) was skipped since it collides with above method
        @typing.overload
        def __call__(self, value: str) -> None:...
        # Method WriteValue(value : Byte) was skipped since it collides with above method
        # Method WriteValue(value : SByte) was skipped since it collides with above method
        @typing.overload
        def __call__(self, value: Decimal) -> None:...
        @typing.overload
        def __call__(self, value: Array_1[int]) -> None:...
        # Method WriteValue(value : String) was skipped since it collides with above method
        # Method WriteValue(value : Boolean) was skipped since it collides with above method
        @typing.overload
        def __call__(self, value: DateTime) -> None:...
        @typing.overload
        def __call__(self, value: DateTimeOffset) -> None:...
        @typing.overload
        def __call__(self, value: TimeSpan) -> None:...
        @typing.overload
        def __call__(self, value: Guid) -> None:...
        @typing.overload
        def __call__(self, value: Uri) -> None:...
        @typing.overload
        def __call__(self, value: typing.Any) -> None:...



class JValue(JToken, IConvertible, IComparable_1[JValue], IComparable, IFormattable, IEquatable_1[JValue]):
    # Constructor .ctor(value : UInt64) was skipped since it collides with above method
    # Constructor .ctor(value : Double) was skipped since it collides with above method
    # Constructor .ctor(value : Single) was skipped since it collides with above method
    # Constructor .ctor(value : Boolean) was skipped since it collides with above method
    # Constructor .ctor(value : String) was skipped since it collides with above method
    @typing.overload
    def __init__(self, other: JValue) -> None: ...
    @typing.overload
    def __init__(self, value: int) -> None: ...
    @typing.overload
    def __init__(self, value: Decimal) -> None: ...
    @typing.overload
    def __init__(self, value: str) -> None: ...
    @typing.overload
    def __init__(self, value: DateTime) -> None: ...
    @typing.overload
    def __init__(self, value: DateTimeOffset) -> None: ...
    @typing.overload
    def __init__(self, value: Guid) -> None: ...
    @typing.overload
    def __init__(self, value: Uri) -> None: ...
    @typing.overload
    def __init__(self, value: TimeSpan) -> None: ...
    @typing.overload
    def __init__(self, value: typing.Any) -> None: ...
    @property
    def First(self) -> JToken: ...
    @property
    def HasValues(self) -> bool: ...
    @property
    def Item(self) -> JToken: ...
    @Item.setter
    def Item(self, value: JToken) -> JToken: ...
    @property
    def Last(self) -> JToken: ...
    @property
    def Next(self) -> JToken: ...
    @Next.setter
    def Next(self, value: JToken) -> JToken: ...
    @property
    def Parent(self) -> JContainer: ...
    @Parent.setter
    def Parent(self, value: JContainer) -> JContainer: ...
    @property
    def Path(self) -> str: ...
    @property
    def Previous(self) -> JToken: ...
    @Previous.setter
    def Previous(self, value: JToken) -> JToken: ...
    @property
    def Root(self) -> JToken: ...
    @property
    def Type(self) -> JTokenType: ...
    @property
    def Value(self) -> typing.Any: ...
    @Value.setter
    def Value(self, value: typing.Any) -> typing.Any: ...
    def CompareTo(self, obj: JValue) -> int: ...
    @staticmethod
    def CreateComment(value: str) -> JValue: ...
    @staticmethod
    def CreateNull() -> JValue: ...
    @staticmethod
    def CreateString(value: str) -> JValue: ...
    @staticmethod
    def CreateUndefined() -> JValue: ...
    def GetHashCode(self) -> int: ...
    def WriteTo(self, writer: JsonWriter, converters: Array_1[JsonConverter]) -> None: ...
    def WriteToAsync(self, writer: JsonWriter, cancellationToken: CancellationToken, converters: Array_1[JsonConverter]) -> Task: ...
    # Skipped Equals due to it being static, abstract and generic.

    Equals : Equals_MethodGroup
    class Equals_MethodGroup:
        @typing.overload
        def __call__(self, other: JValue) -> bool:...
        @typing.overload
        def __call__(self, obj: typing.Any) -> bool:...

    # Skipped ToString due to it being static, abstract and generic.

    ToString : ToString_MethodGroup
    class ToString_MethodGroup:
        @typing.overload
        def __call__(self) -> str:...
        @typing.overload
        def __call__(self, format: str) -> str:...
        @typing.overload
        def __call__(self, formatProvider: IFormatProvider) -> str:...
        @typing.overload
        def __call__(self, format: str, formatProvider: IFormatProvider) -> str:...



class LineInfoHandling(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Ignore : LineInfoHandling # 0
    Load : LineInfoHandling # 1


class MergeArrayHandling(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Concat : MergeArrayHandling # 0
    Union : MergeArrayHandling # 1
    Replace : MergeArrayHandling # 2
    Merge : MergeArrayHandling # 3


class MergeNullValueHandling(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Ignore : MergeNullValueHandling # 0
    Merge : MergeNullValueHandling # 1

