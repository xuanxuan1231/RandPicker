import typing, clr, abc
from Newtonsoft.Json.Linq import JToken
from System.Collections.Generic import IList_1, IDictionary_2
from Newtonsoft.Json import JsonReader, JsonWriter, JsonException
from System.Runtime.Serialization import SerializationInfo, StreamingContext
from System import Exception, EventArgs, MulticastDelegate, IAsyncResult, AsyncCallback
from System.Collections import IDictionary
from System.Reflection import MethodBase, MethodInfo
from Newtonsoft.Json.Serialization import IContractResolver

class Extensions(abc.ABC):
    # Skipped IsValid due to it being static, abstract and generic.

    IsValid : IsValid_MethodGroup
    class IsValid_MethodGroup:
        @typing.overload
        def __call__(self, source: JToken, schema: JsonSchema) -> bool:...
        @typing.overload
        def __call__(self, source: JToken, schema: JsonSchema, errorMessages: clr.Reference[IList_1[str]]) -> bool:...

    # Skipped Validate due to it being static, abstract and generic.

    Validate : Validate_MethodGroup
    class Validate_MethodGroup:
        @typing.overload
        def __call__(self, source: JToken, schema: JsonSchema) -> None:...
        @typing.overload
        def __call__(self, source: JToken, schema: JsonSchema, validationEventHandler: ValidationEventHandler) -> None:...



class JsonSchema:
    def __init__(self) -> None: ...
    @property
    def AdditionalItems(self) -> JsonSchema: ...
    @AdditionalItems.setter
    def AdditionalItems(self, value: JsonSchema) -> JsonSchema: ...
    @property
    def AdditionalProperties(self) -> JsonSchema: ...
    @AdditionalProperties.setter
    def AdditionalProperties(self, value: JsonSchema) -> JsonSchema: ...
    @property
    def AllowAdditionalItems(self) -> bool: ...
    @AllowAdditionalItems.setter
    def AllowAdditionalItems(self, value: bool) -> bool: ...
    @property
    def AllowAdditionalProperties(self) -> bool: ...
    @AllowAdditionalProperties.setter
    def AllowAdditionalProperties(self, value: bool) -> bool: ...
    @property
    def Default(self) -> JToken: ...
    @Default.setter
    def Default(self, value: JToken) -> JToken: ...
    @property
    def Description(self) -> str: ...
    @Description.setter
    def Description(self, value: str) -> str: ...
    @property
    def Disallow(self) -> typing.Optional[JsonSchemaType]: ...
    @Disallow.setter
    def Disallow(self, value: typing.Optional[JsonSchemaType]) -> typing.Optional[JsonSchemaType]: ...
    @property
    def DivisibleBy(self) -> typing.Optional[float]: ...
    @DivisibleBy.setter
    def DivisibleBy(self, value: typing.Optional[float]) -> typing.Optional[float]: ...
    @property
    def Enum(self) -> IList_1[JToken]: ...
    @Enum.setter
    def Enum(self, value: IList_1[JToken]) -> IList_1[JToken]: ...
    @property
    def ExclusiveMaximum(self) -> typing.Optional[bool]: ...
    @ExclusiveMaximum.setter
    def ExclusiveMaximum(self, value: typing.Optional[bool]) -> typing.Optional[bool]: ...
    @property
    def ExclusiveMinimum(self) -> typing.Optional[bool]: ...
    @ExclusiveMinimum.setter
    def ExclusiveMinimum(self, value: typing.Optional[bool]) -> typing.Optional[bool]: ...
    @property
    def Extends(self) -> IList_1[JsonSchema]: ...
    @Extends.setter
    def Extends(self, value: IList_1[JsonSchema]) -> IList_1[JsonSchema]: ...
    @property
    def Format(self) -> str: ...
    @Format.setter
    def Format(self, value: str) -> str: ...
    @property
    def Hidden(self) -> typing.Optional[bool]: ...
    @Hidden.setter
    def Hidden(self, value: typing.Optional[bool]) -> typing.Optional[bool]: ...
    @property
    def Id(self) -> str: ...
    @Id.setter
    def Id(self, value: str) -> str: ...
    @property
    def Items(self) -> IList_1[JsonSchema]: ...
    @Items.setter
    def Items(self, value: IList_1[JsonSchema]) -> IList_1[JsonSchema]: ...
    @property
    def Maximum(self) -> typing.Optional[float]: ...
    @Maximum.setter
    def Maximum(self, value: typing.Optional[float]) -> typing.Optional[float]: ...
    @property
    def MaximumItems(self) -> typing.Optional[int]: ...
    @MaximumItems.setter
    def MaximumItems(self, value: typing.Optional[int]) -> typing.Optional[int]: ...
    @property
    def MaximumLength(self) -> typing.Optional[int]: ...
    @MaximumLength.setter
    def MaximumLength(self, value: typing.Optional[int]) -> typing.Optional[int]: ...
    @property
    def Minimum(self) -> typing.Optional[float]: ...
    @Minimum.setter
    def Minimum(self, value: typing.Optional[float]) -> typing.Optional[float]: ...
    @property
    def MinimumItems(self) -> typing.Optional[int]: ...
    @MinimumItems.setter
    def MinimumItems(self, value: typing.Optional[int]) -> typing.Optional[int]: ...
    @property
    def MinimumLength(self) -> typing.Optional[int]: ...
    @MinimumLength.setter
    def MinimumLength(self, value: typing.Optional[int]) -> typing.Optional[int]: ...
    @property
    def Pattern(self) -> str: ...
    @Pattern.setter
    def Pattern(self, value: str) -> str: ...
    @property
    def PatternProperties(self) -> IDictionary_2[str, JsonSchema]: ...
    @PatternProperties.setter
    def PatternProperties(self, value: IDictionary_2[str, JsonSchema]) -> IDictionary_2[str, JsonSchema]: ...
    @property
    def PositionalItemsValidation(self) -> bool: ...
    @PositionalItemsValidation.setter
    def PositionalItemsValidation(self, value: bool) -> bool: ...
    @property
    def Properties(self) -> IDictionary_2[str, JsonSchema]: ...
    @Properties.setter
    def Properties(self, value: IDictionary_2[str, JsonSchema]) -> IDictionary_2[str, JsonSchema]: ...
    @property
    def ReadOnly(self) -> typing.Optional[bool]: ...
    @ReadOnly.setter
    def ReadOnly(self, value: typing.Optional[bool]) -> typing.Optional[bool]: ...
    @property
    def Required(self) -> typing.Optional[bool]: ...
    @Required.setter
    def Required(self, value: typing.Optional[bool]) -> typing.Optional[bool]: ...
    @property
    def Requires(self) -> str: ...
    @Requires.setter
    def Requires(self, value: str) -> str: ...
    @property
    def Title(self) -> str: ...
    @Title.setter
    def Title(self, value: str) -> str: ...
    @property
    def Transient(self) -> typing.Optional[bool]: ...
    @Transient.setter
    def Transient(self, value: typing.Optional[bool]) -> typing.Optional[bool]: ...
    @property
    def Type(self) -> typing.Optional[JsonSchemaType]: ...
    @Type.setter
    def Type(self, value: typing.Optional[JsonSchemaType]) -> typing.Optional[JsonSchemaType]: ...
    @property
    def UniqueItems(self) -> bool: ...
    @UniqueItems.setter
    def UniqueItems(self, value: bool) -> bool: ...
    def ToString(self) -> str: ...
    # Skipped Parse due to it being static, abstract and generic.

    Parse : Parse_MethodGroup
    class Parse_MethodGroup:
        @typing.overload
        def __call__(self, json: str) -> JsonSchema:...
        @typing.overload
        def __call__(self, json: str, resolver: JsonSchemaResolver) -> JsonSchema:...

    # Skipped Read due to it being static, abstract and generic.

    Read : Read_MethodGroup
    class Read_MethodGroup:
        @typing.overload
        def __call__(self, reader: JsonReader) -> JsonSchema:...
        @typing.overload
        def __call__(self, reader: JsonReader, resolver: JsonSchemaResolver) -> JsonSchema:...

    # Skipped WriteTo due to it being static, abstract and generic.

    WriteTo : WriteTo_MethodGroup
    class WriteTo_MethodGroup:
        @typing.overload
        def __call__(self, writer: JsonWriter) -> None:...
        @typing.overload
        def __call__(self, writer: JsonWriter, resolver: JsonSchemaResolver) -> None:...



class JsonSchemaException(JsonException):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, info: SerializationInfo, context: StreamingContext) -> None: ...
    @typing.overload
    def __init__(self, message: str) -> None: ...
    @typing.overload
    def __init__(self, message: str, innerException: Exception) -> None: ...
    @property
    def Data(self) -> IDictionary: ...
    @property
    def HelpLink(self) -> str: ...
    @HelpLink.setter
    def HelpLink(self, value: str) -> str: ...
    @property
    def HResult(self) -> int: ...
    @HResult.setter
    def HResult(self, value: int) -> int: ...
    @property
    def InnerException(self) -> Exception: ...
    @property
    def LineNumber(self) -> int: ...
    @property
    def LinePosition(self) -> int: ...
    @property
    def Message(self) -> str: ...
    @property
    def Path(self) -> str: ...
    @property
    def Source(self) -> str: ...
    @Source.setter
    def Source(self, value: str) -> str: ...
    @property
    def StackTrace(self) -> str: ...
    @property
    def TargetSite(self) -> MethodBase: ...


class JsonSchemaGenerator:
    def __init__(self) -> None: ...
    @property
    def ContractResolver(self) -> IContractResolver: ...
    @ContractResolver.setter
    def ContractResolver(self, value: IContractResolver) -> IContractResolver: ...
    @property
    def UndefinedSchemaIdHandling(self) -> UndefinedSchemaIdHandling: ...
    @UndefinedSchemaIdHandling.setter
    def UndefinedSchemaIdHandling(self, value: UndefinedSchemaIdHandling) -> UndefinedSchemaIdHandling: ...
    # Skipped Generate due to it being static, abstract and generic.

    Generate : Generate_MethodGroup
    class Generate_MethodGroup:
        @typing.overload
        def __call__(self, type: typing.Type[typing.Any]) -> JsonSchema:...
        @typing.overload
        def __call__(self, type: typing.Type[typing.Any], rootSchemaNullable: bool) -> JsonSchema:...
        @typing.overload
        def __call__(self, type: typing.Type[typing.Any], resolver: JsonSchemaResolver) -> JsonSchema:...
        @typing.overload
        def __call__(self, type: typing.Type[typing.Any], resolver: JsonSchemaResolver, rootSchemaNullable: bool) -> JsonSchema:...



class JsonSchemaResolver:
    def __init__(self) -> None: ...
    @property
    def LoadedSchemas(self) -> IList_1[JsonSchema]: ...
    @LoadedSchemas.setter
    def LoadedSchemas(self, value: IList_1[JsonSchema]) -> IList_1[JsonSchema]: ...
    def GetSchema(self, reference: str) -> JsonSchema: ...


class JsonSchemaType(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    None_ : JsonSchemaType # 0
    String : JsonSchemaType # 1
    Float : JsonSchemaType # 2
    Integer : JsonSchemaType # 4
    Boolean : JsonSchemaType # 8
    Object : JsonSchemaType # 16
    Array : JsonSchemaType # 32
    Null : JsonSchemaType # 64
    Any : JsonSchemaType # 127


class UndefinedSchemaIdHandling(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    None_ : UndefinedSchemaIdHandling # 0
    UseTypeName : UndefinedSchemaIdHandling # 1
    UseAssemblyQualifiedName : UndefinedSchemaIdHandling # 2


class ValidationEventArgs(EventArgs):
    @property
    def Exception(self) -> JsonSchemaException: ...
    @property
    def Message(self) -> str: ...
    @property
    def Path(self) -> str: ...


class ValidationEventHandler(MulticastDelegate):
    def __init__(self, object: typing.Any, method: int) -> None: ...
    @property
    def Method(self) -> MethodInfo: ...
    @property
    def Target(self) -> typing.Any: ...
    def BeginInvoke(self, sender: typing.Any, e: ValidationEventArgs, callback: AsyncCallback, object: typing.Any) -> IAsyncResult: ...
    def EndInvoke(self, result: IAsyncResult) -> None: ...
    def Invoke(self, sender: typing.Any, e: ValidationEventArgs) -> None: ...

